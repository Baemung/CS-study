# 개발상식
- 클린코드 & 리팩토링 & 시큐어코딩
- 애자일
- TDD
- DDD
- MSA
- OOP
- [OOP의 5가지 설계 원칙](#oop의-5가지-설계-원칙)
- 함수형 프로그래밍
- DevOps
- 3rd Party
- Git , Github, Gitlab
- REST API
- Parameter vs Argument
- Sync vs Async
- XSS
- [도커와 쿠버네티스](#도커란?)

<br>

# OOP의 5가지 설계 원칙

SOLID

- [SRP(단일 책임 원칙)](#srp)
- [OCP(개방 폐쇄 원칙)](#ocp)
- [LSP(리스코프 치환 원칙)](#lsp)
- [ISP(인터페이스 분리 원칙)](#isp)
- [DIP(의존관계 역전 원칙)](#dip)

디자인 패턴이 특별한 상황에서 발생하는 문제에대한 구체적인 솔루션이라면

객체지향 설계원칙은 좀 더 일반적인 상황에서 적용가능한 설계기준입니다.

객체지향의 5가지 원칙을 지키면 객체지향의 가장 큰 장점을 극대화 할 수 있습니다.

## SRP

단일 책임 원칙

"한 클래스는 하나의 책임만을 가져야한다"는 원칙입니다.

예를들면 커뮤니티 사이트에서 회원 정보를 관리할 때, 회원의 정보와 회원이 작성한 게시글에대한 정보까지 하나의 클래스에서 관리하면 게시글에대한 변경사항이 있을 때, 회원 클래스를 수정해야합니다.

이처럼 변경사항이 있을 때, 그 변경에대해서 그와 관련된 부분만 수정할 수 있도록 설계해야한다는 원칙이 단일 책임 원칙입니다.

단일 책임 원칙에서 가장 중요한 것은 각각의 클래스가 가지는 책임의 범위를 적절하게 잘 조절하는 것입니다.

## OCP

개방 폐쇄 원칙

"확장에는 열려있고 변경에는 닫혀있다."는 원칙입니다.

여기서 확장과 변경의 의미는 다음과 같습니다.

확장 - 기능을 변경하거나 확장하는 것을 의미

변경 - 확장된 기능을 사용하는 코드를 수정하는 것을 의미

다형성을 활용해서 인터페이스를 구현한 새로운 클래스를 만들고 거기에 새로운 기능을 구현해주는 방식입니다.

예를들면, 게시판에 업로드를 하는 부분에대한 기능의 확장이 있을 때, 업로드 기능을 사용하는 부분에서는 기존에 사용하던 방식을 그대로 사용할 수 있도록 하는 것을 의미합니다.

하지만, 구현 객체를 변경하려면 클라이언트 코드를 변경해야하기 때문에, 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요합니다. 

→ 이 과정을 스프링이 대신 해줍니다^^

## LSP

리스코프 치환 원칙

"인터페이스를 구현한 구현체 즉, 하위 클래스는 인터페이스의 규약을 다 지켜야한다."는 원칙입니다.

인터페이스를 구현한 구현체의 신뢰성을 올리기위한 원칙으로 상위 타입의 객체를 하위 타입의 객체로 형변환 해도 정상적으로 작동할 수 있도록 하기 위해서 적용합니다.

## ISP

인터페이스 분리 원칙

"인터페이스의 기능을 적당한 크기로 나눠서 인터페이스를 더 명확하고 대체 가능성을 높여야한다"는 원칙입니다.

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 좋다는 의미입니다.

예를 들면, 커뮤니티 사이트에서 북마크 기능을 개발할 때, 회원 북마크 기능과 게시글 북마크 기능을 개발을 할 때, 북마크 기능 전체에대한 범용 인터페이스보다는 회원 북마크용 인터페이스와 게시글 북마크용 인터페이스를 만들어두는게 좋습니다. 

## DIP

의존관계 역전 원칙

"추상화에 의존해야지, 구체화에 의존하면 안된다."라는 원칙입니다.

의존성 주입은 이 원칙을 따르는 방법 중 하나입니다. 

OCP와 연관이 있는 원칙입니다.

클라이언트 코드가 구현 클래스가 아닌 인터페이스를 바라보게해서, 인터페이스에서 어떤 구현 클래스를 사용할지 선택하게 하는 방식입니다.

이런 방식으로 개발해야하는 이유는 역할에 의존하지않고 구현에 해당하는 구현체에 의존하게되면 변경시에 불필요한 코드 수정이 많이 발생하기 때문입니다.

OCP와 마찬가지로 다형성만으로는 구현 객체를 변경할 때, 클라이언트 코드도 변경해야하기 때문에 DIP를 지키기 어렵습니다. 

→ 그래서 스프링이 필요합니다!

# 도커란?

도커는 **'컨테이너 기반의 오픈소스 가상화 플랫폼'**
- 도커로 컨테이너를 띄운다.
- 컨테이너란?<br>
  애플리케이션 & 애플리케이션을 구동하는 환경을 격리한 공간<br>
  컨테이너에 프로그램을 띄워서 돌린다고 생각하면 된다.<br>
  보통 마이크로 서비스로 사용된다.<br>
    - 거대한 어플리케이션을 기능별로 나누어 변경/조합이 가능하게 한 것
    - 컨테이너를 사용하면 하나의 큰 어플을 서비스 단위로 잘라 빠르게 배포 가능.
    - 그리고 각각 분리해서 쓰니 변경사항이 분리된 다른 기능들에 영향 미치지 않음.

<br>

**기존의 가상머신(VM)과 컨테이너의 차이점**
<p align="center">
<img src="https://user-images.githubusercontent.com/67310666/127528645-e66d5480-6ab2-4816-8e59-4030f489b077.png" width="90%">
</p>

- 기존의 가상머신(VM) 서버
    - Server -> Hypervisor -> 각각의 Guest OS가 설치된 VM 구동
    - 가상 머신의 모든 자원을 사용
- 컨테이너 서버 <br>
    - Server -> Host OS -> Docker Engine -> Container 올리기
    - CPU, RAM, Disk, Network와 같은 운영체제의 자원을 필요한 만큼 컨테이너에 할당
    - 효율적!! 배포가 빠름!! but 컨테이너 하나가 자원을 많이 사용하면 장애 발생.
- 도커가 가진 컨테이너는 독립적이고 동적이다.
    - if, 당신의 app이 인기가 많아지면 그 컨테이너의 수를 늘리고, 다시 트래픽이 줄면 해당 컨테이너 수를 줄이면 된다. 
    - 즉, 도커 덕분에 매번 새로운 서비스를 만들 때마다 새로운 서비스를 사고, 설정할 필요가 없음
    - 하나의 같은 서버에 각기 다른 환경의 컨테이너를 설정할 수 있고, 이 컨테이너들은 각각 분리, 독립되어 있는 것이기 때문에 더욱 효율적
    <br>

```
쉽게 말하자면!
가상 컴퓨팅은 한 물리적 컴퓨터 안에 각각 OS를 가동하는 가상 컴퓨터들이 물리적 자원을 분할해서 쓰기 때문에 성능에 한계가 있음!
도커는 OS단까지 내려가는게 아니라 실행 환경만 독립적으로 돌리는 거라서 컴퓨터에 직접 요소들을 설치한거랑 별 차이 없는 성능을 낼 수 있음!
```
<br>

Youtube ["도커가 뭐고 왜 쓰는건가요?"](https://youtu.be/tPjpcsgxgWc)

<br>

# 쿠버네티스란?
<p align="center">
<img src="https://user-images.githubusercontent.com/67310666/128356721-8d8fc51a-eaf7-42b8-be50-5bbecd205523.png" width="50%">
</p>

쿠퍼네티스는 **'컨테이너 오케스트레이션 툴'**
- 오케스트레이션이란?<br>
컨테이너 수가 많아지면 관리와 운영에 있어 어려움이 있음. <br>
이러한 다수의 컨테이너 실행을 관리 및 조율하는 시스템.
오케스트레이션 엔진을 통해 컨테이너의 생성과 소멸, 시작 및 중단 시점 제어, 스케줄링, 로드 밸런싱, 클러스터링 등 컨테이너로 어플리케이션을 구성하는 모든 과정을 관리할 수 있음.

