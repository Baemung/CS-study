# 개발상식
- 클린코드 & 리팩토링 & 시큐어코딩
- [애자일](#애자일) 
- [TDD](#TDD)
- DDD
- [MSA](#msa(microservices-architecture))
- [OOP](#oop)
- [OOP의 5가지 설계 원칙](#oop의-5가지-설계-원칙)
- 함수형 프로그래밍
- DevOps
- 3rd Party
- Git , Github, Gitlab
- REST API
- Parameter vs Argument
- [Sync vs Async](#동기vs비동기)
- XSS
- [도커와 쿠버네티스](#도커란)

<br>

# 애자일
## 애자일 이란?
* ‘Agile = 기민한, 날렵한’ 이란 뜻으로 좋은 것을 빠르게 취하고, 낭비 없게 만드는 다양한 방법론을 통칭해 일컫는 말

* 절차보다는 사람이 중심이 되어 **변화에 유연하고 신속하게 적응하며, 효율적인 시스템을 개발**하는 방법론

* **반복적/점증적인 짧은 개발주기, 위험도를 감소시키고 고객의 요구사항 수용의 민첩성이 강조**된 개발 방법론

<br>

## 애자일 방법론의 진행 과정
* 애자일 방법론은 **계획 → 설계(디자인) → 개발(발전) → 테스트 → 검토(피드백)** 순으로 반복적으로 진행됩니다. 계획을 세운 후 다음 단계까지 기다려서 절차대로 진행하는 워터폴 모델과 달리 먼저 진행 후 분석, 시험, 피드백을 통하여 개선하여 나가는 진행 모델입니다.

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/129449270-4b75d314-3c3d-447c-9a08-8e2b0413c9ed.jpeg" width="60%">
</p>

1. **계획 및 분석** : 고객과 사용자가 원하는 바를 파악하여 타당성을 조사하고 SW 기능과 제약조건을 정의하는 명세서 작성, 대상이 되는 문제 영역과 사용자가 원하는 task를 이해하는 단계
2. **설계(디자인)** : 기획의도에 맞는 설계 및 디자인 추가 및 수정하는 단계
3. **개발(발전)** : 설계단계에서 만들어진 설계서를 바탕으로 프로그램을 작성, 코딩, 디버깅, 단위/통합테스트 수행
4. **테스트** : 발생 가능한 실행 프로그램 오류를 발견, 수정하는 단계
5. **검토(피드백)** : 기획의도를 파악하고 시험결과와 기획의 따라 수정할 부분을 제시하는 단계

<br>

## 애자일 방법론의 특징
* 고객과 개발자의 **지속적인 소통**을 통하여 변화하는 요구사항을 신속하게 수용한다.
* 개발자 개인의 가치보다는 팀의 목적을 우선시하며 **고객의 의견을 가장 우선시**한다.
* **팀원들과의 주기적인 회의 및 제품 시현**을 통한 방지를 점검한다.
* 진행하면서 프로그램을 시행해보고 **고객으로부터 피드백**을 받는다.
* 내부 구조 형성을 통한 **비용절감**에 힘쓰는 동시에 **프로그램 품질 향상**을 위해 노력한다.

<br>

## 애자일 방법론의 장/단점
### 장점 👍
* **프로젝트 계획에 걸리는 시간을 최소화**할 수 있다.
* 점진적으로 테스트할 수 있어서 **버그를 쉽고 빠르게 발견할 수 있다.**
* 계획 혹은 기능에 대한 **수정과 변경에 유연**하다.
* 고객 요구사항에 대한 **즉각적인 피드백에 유연하며 프로토타입 모델을 빠르게 출시**할 수 있다.
* 빠듯한 기한의 프로젝트를 **빠르게 출시**할 수 있다.

### 단점 👎
* 확정되지 않은 계획 및 요구사항으로 인한 **반복적인 유지보수 작업이 많다.**
* 고객의 요구사항 및 계획이 크게 변경될 경우 모델이 무너질 수 있다.
* 개인이 아닌 팀이 중심이 되다 보니 **공통으로 해야 할 작업들이 많을 수 있다.** (회의, 로그 등)
* 반복적인 업무로 속도는 빠를 수 있으나 **미흡한 기능들에 대한 대처가 필요**하다.
* 확정되지 않은 계획으로 **개발 진행 시 이해하지 못하고 진행하는 부분이 많을 수 있다.**

<br>

## 애자일 방법론의 종류
### 익스트림 프로그래밍(Extreme Programming, XP)
* 문서를 강조하지 않고 테스트를 우선하는 개발 방식, **개발 초기부터 테스트를 병행**하는 개발 방법론
* 고객과 함께 **2주 정도의 반복개발**
* 의사소통, 피드백, 단순성, 용기, 존중 강조

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/129449766-b5ca72c9-b3e4-4bac-981e-ca2b7fd4755d.png" width="50%">
</p>

1. **유저스토리** : 사용자 요구사항 수집, 의사소통 도구
2. **구조적 스파이크** : 설계상,기술상  잠재적 위험을 탐지하기 위한 간단한 프로그램, 기술적인 문제를 줄이고 유저 스토리 기반 개발일정에 대한 신뢰도 상승
3. **릴리즈 계획** : 전체 프로젝트 배포계획 확립
4. **주기** : XP핵심, 상황에 따른 릴리즈 및 계획수정
5. **승인 테스트** : 릴리즈 전의 인수 테스트(블랙박스 테스트), 고객수행
6. **작은 릴리즈** : 주기의 마지막 단계, 빠른 피드백

<br>

### 스크럼(Scrum)
* 30일마다 동작 가능한 제품을 제공하는 **스플린트를 중심**, 팀을 중심으로 한 반복적이고 점진적인 개발 방법론
* **제품 백로그**를 바탕으로 기술적으로 분할되고 **재해석된 스프린트**를 통해 구현하는 개발 방법론
* XP는 변화수용, 스크럼은 **선감지 처리 관점**

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/129450311-cab3f342-1ac5-4d8e-a05c-c30624f7b5e0.png" width="70%">
</p>

#### 구성요소
* **Sprint** : 반복주기 (Iteration, 30days)
* **Product Backlog** : 제품의 요구사항 목록
* **Sprint Backlog** : 해당 Sprint기간에 수행해야하는 Task 목록
* **Daily Scrum Meeting** : 매일 15분 정도 짧게 진행하는 미팅 (계획, 실적, 위험 공유)
* **Review** : Sprint 완료 시 고객 검토, Feedback을 받아 다음 Product Backlog에 적용
* **Retrospective Meeting** : Scrum Team에서 운영중인 시험 리뷰 및 개선 미팅
* **Burn Down/Up Chart** : 하나의 스프린트에 대한 소멸/완성 그래프

#### 역할자
* **Product Owner** : 요구사항을 정의하고 Product Backlog 업데이트
* **Scrum Team** : Product Backlog 구현
* **Scrum Master** : 제 3자 입장에서 Product Owner와 Scrum Team이 Scrum방법론을 제대로 진행 할 수 있도록 지원

***따라서 Scrum을 적용하려면 조직의 역할/구성/감리/산출물 등 다양한 영역에서 변화를 주어야 함***

<br>

### KANBAN (칸반)
* **연속적 흐름 처리** 방식. **칸반 보드**로 시각화되고 각각 단계는 열로 표시

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/129450158-f00a677f-46d1-4d09-bb2b-52af95104dc2.png" width="70%">
</p>

#### 구성요소
* **Kanban Board** : 프로세스를 가진 Board와 스토리카드를 이용하여 업무 흐름제어
* **Process** : 실제 업무가 이루어지는 단계 및 업무 수행을 통한 산출물 작성
* **Work Queue** : 대기형렬, 개발 대기, 테스트 대기, 배포/릴리즈 대기 과정
* **Total Work Time (총 주기 시간)** : 총 작업의 수행시간, 개별 업무의 Cycle Time의 합으로 구성

<br>

----

# TDD

TDD(Test Driven Development)는 테스트 주도 개발이라는 뜻으로 만들고자하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증까지 해줄 수 있도록 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법입니다.

그렇다면 테스트는 과연 무엇일까요?

## 테스트는 무엇인가

테스트는 만든 코드에 확신을 가질 수 있게 해주는 도구입니다. 테스트를 통해 검증한 코드는 정상적으로 작동한다는 확신을 가질 수 있으며, 변화한 부분 이외의 부분은 검증이 완료된 상태이기 때문에, 변경한 부분으로 인해 발생하는 변화만 신경쓰면 되기 때문에 변화에 유연하게 대처할 수 있게 해줍니다.

테스트는 개발자가 의도한대로 코드가 정확히 작동하는지 확인하는 것이기 때문에, 테스트하려는 대상에 집중할 수 있는 사이즈로 만드는 것이 중요합니다. 그렇기 때문에 관심사의 분리를 통해서 적당한 사이즈로 단위 테스트를 만들어야합니다.

단위 테스트를 하는 이유는 웹 개발을 예시로 설명을 해보겠습니다.

웹 개발 초기에 회원 가입 기능을 개발하고 있는 상황을 생각해보면, DB에 데이터가 잘 들어가는지 확인을 하려고 할 때, 단위 테스트를 사용하지않으면, 프론트 코드까지 작성을 해서 데이터를 넘겨받아와서 저장하는 기능까지 구현을 해놓은 다음에 제대로 작동하는지 확인해야합니다. 이런 식으로 개발을 하면, 문제가 발생했을 때, 어디서 발생했는지 확인이 힘들 뿐만 아니라 초기에 간단하게 대응할 수 있었던 문제를 엄청 복잡한 과정을 통해 해결해야하는 일이 생길 수 있습니다. 그렇기 때문에 관심사에 맞는 크기의 단위 테스트를 만들어 테스트 하는 것이 중요합니다.

그렇다면 테스트를 작성할 때 어떤 점을 유의해야하는지 알아보겠습니다.

### 1. 테스트는 자동으로 수행되도록 코드로 만드는 것이 중요하다.

테스트를 진행할 때, 입력에 실수가 있어서 오류가 나면 다시 테스트를 반복해야하고, 테스트를 실행하기위해서 서버를 띄우고 프로그램을 배치한 후, 테스트 용으로 브라우저를 띄우고 주소를 입력해야하는 귀찮은 작업도 필요합니다. 하지만 자동으로 수행되도록 코드를 만들어놓으면 이런 시간을 단축할 수 있으며 **자주 반복이 가능**합니다.

### 2. 지속적인 개선과 점진적인 개발을 위한 테스트를 해야한다.

작성한 코드를 만든 후에 이를 검증하는 테스트 코드를 만들어두면, 코드를 개선하는 작업을 할 때 유리합니다. 혹시 개선 과정 중간에 설계를 잘못하거나, 수정에 실수가 있었다면 테스트를 통해서 바로 확인을 할 수 있기 때문입니다.

그렇기 때문에 이전까지 구현 해놓았던 기능들이 문제 없음을 검증한다면, 조금씩 기능을 추가하면서 테스트트하는 점진적인 개발이 가능해집니다. 테스트를 통해 기존에 만들어둔 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지않고 잘 작동하는지까지도 확인할 수 있기 때문에, 개발 전단계에 걸쳐 테스트는 필수적입니다.

### 3. 테스트 결과는 일관성이 있어야한다.

코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야합니다.
테스트가 외부 상태에 따라서 성공하기도 하고, 실패하기도 한다면 그 테스트는 좋은 테스트라고 할 수 없습니다.

### 4. 포괄적인 테스트를 해야한다.

2번에서 관심사에 따른 단위 테스트를 진행해야한다고 말했는데, 갑자기 포괄적으로 테스트를 해야한다는 말이 나와서 의아할 수 있습니다.

하지만 여기서 말하는 포괄적인 테스트라는 것은 성공하는 테스트만 골라서 만들면 안된다는 뜻입니다.

평소에는 정상적으로 잘 동작하는 것처럼 보이지만 막상 특별한 상황이 되면 엉뚱하게 동작한다면, 이는 추후에 큰 문제를 만들 수 있고 원인을 찾기 힘들어서 고생할 수 있습니다.
"항상 네거티브 테스트를 먼저 만들어라"라는 말이 있을만큼 부정적인 케이스를 먼저 만드는 테스트 습관을 들이는 것이 중요합니다.

## 테스트가 이끄는 개발

앞서 설명했던 것처럼 테스트 주도 개발은 만들고자하는 기능의 내용을 담으면서 만들어진 코드를 검증할 수 있는 코드를 먼저 만든 후에, 그 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법입니다.

이는 테스트를 만들어가면서 개발하는 방법이 주는 극대화한 방법입니다.

> 실패한 테스트를 성공시키기위한 목적이 아닌 코드는 만들지 않는다

는 TDD의 기본 원칙입니다. 

TDD는 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 방식으로 진행하기 때문에, 테스트를 빼먹지 않고 만들 수 있습니다. 그리고 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아져 전체적인 개발 시간이 짧아집니다.

테스트를 만들어뒀기 때문에, 코드를 작성하면 바로바로 테스트를 실행해볼 수 있기 때문입니다. 

TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가도록 권장됩니다. 그래서 TDD 방식은 [애자일](#애자일) 을 통한 개발을 할 때 필수적입니다.

### TDD의 장점

1. 코드를 만들어 테스트를 실행하는 그 간격이 매우 짧기 때문에 개발한 코드의 오류를 빠르게 발견할 수 있습니다. 빨리 발견된 오류는 쉽게 대응이 가능하기 때문에 TDD를 통해서 개발을 하면 개발시간을 단축할 수 있습니다.

2. 테스트 코드는 애플리케이션 코드보다 상대적으로 작성하기 쉽고 각 테스트가 독립적이기 때문에, 코드의 양에 비해서 작성하는 시간이 얼마 걸리지않습니다.

3. 개발하고 싶은 기능을 일반 언어가 아닌 테스트 코드로 표현해서, 마치 코드로 된 설계문서처럼 만들어놓을 수 있습니다. 이렇게 설계 문서처럼 만들어 놓은 후에 실제 기능을 가진 애플리케이션 코드를 만들고 나면, 그 테스트를 바로 실행해서 설계한대로 코드가 작동하는지 확인할 수 있습니다.

   이때 테스트가 실패하면 설계한 대로 코드가 만들어지지 않았다는 것을 바로 알 수 있습니다. 이 과정에서 문제가되는 부분을 알 수 있고, 다시 코드를 수정하고 테스트를 수행해서 테스트가 성공하도록 코드를 계속 다듬어가면서 테스트를 끝내면 코드의 구현과 테스트라는 두가지 작업이 동시에 끝나기 때문에 정말 효율적입니다.

   

----

# MSA(Microservices Architecture)

MSA(Microservices Architecture)는 하나의 큰 어플리케이션을 여러 개의  작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐입니다.

Microservices 는 특정 도메인을 중심으로 비즈니스 로직을 처리하는 핵심 기능 서비스입니다. 

각 서비스는 다른 서비스들과 API 같은 수단으로 서로 통신하며 독립적으로 작동할 수 있습니다. 

MSA는 SOA(Service-Oriented Architecture)가 발전된 형태로 생각할 수 있습니다.

[Monolithic vs SOA vs Microservice 비교](https://wonit.tistory.com/487)



## Monolithic VS Microservices

<p align="center"><img src="img/MSA_Monolithic_Microservices.png" width="600"></p>

**Monolithic Architecture**는 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어있는 아키텍쳐입니다.

즉, 하나의 프로젝트에 코드가 모여있고 하나의 파일로 구성됩니다. 보통 DB, View, Controller로 구성된 컴포넌트들이 **하나의 프로젝트에서 관리**되고 **하나의 공통된 DB**를 바라보고 있다는 특징이 있습니다. 

아직까지는 많은 소프트웨어가 Monolithic 형태로 구현되어 있습니다. 특히 소규모 프로젝트에는 Monolithic Architecture가 테스트 및 배포 파이프라인 구성이 간단하고 유지보수가 용이하기 때문에 훨씬 합리적입니다. 

하지만 일정 규모 이상의 서비스, 혹은 수백명의 개발자가 투입되는 프로젝트에서 Monolithic Architecture은 뚜렷한 한계를 보입니다.

- **서비스 간의 의존성이 크고** 서비스/프로젝트가 커지면 커질수록, 영향도 파악 및 전체 시스템 구조의 파악에 어려움이 있습니다.
- 작은 수정에도 시스템 전체를 빌드해야 하며, 빌드 시간 및 테스트 시간, 그리고 배포 시간이 기하급수적으로 늘어나게 됩니다.
- 서비스를 부분적으로 scale-out하기가 어렵습니다.
- 부분의 장애가 전체 서비스의 장애로 이어지는 경우가 발생하게 됩니다. => Single point of failure
  - ex) 상품, 주문, 결제 서비스 중 하나라도 에러가 발생하면 어플리케이션의 다른 모든 서비스를 사용할 수 없다.

**Microservices Architecture**는 서비스가 커지면서 생겼던 Monolithic Architecture의 한계들을 어느정도 보완해 줄 수 있습니다.

- 서비스를 분리하였기 때문에 서비스 간의 의존성이 낮습니다.
  - 서비스별로 신기술과 최적화된 기술(ex.데이터베이스 구조)을 독립적으로 사용 할 수 있습니다.
- 서비스 단위로 빌드, 테스트 및 배포가 가능하며, 전체 서비스의 중단 없이 서비스 별 배포가 가능합니다. 

- 서비스는 개별 프로세서에서 동작하기 때문에 새로운 컨테이너에 대한 추가가 자유롭습니다. 그래서 특정 서비스에  대한 scale-out이 용이합니다.
- 장애가 발생한 서비스의 격리가 가능하여 장애가 전체 서비스로 확장될 가능성이 낮습니다.



## MSA의 문제점

<p align="center"><img src="img/MSA_msa.png" width="600"></p>

그림을 보더라도 알 수 있지만 MSA를 구축하는 일은 **쉬운 일이 아닙니다.**

MSA는 매우 복잡한 아키텍쳐로, 전체 서비스가 커짐에 따라 그 복잡도가 기하급수적으로 늘어날 수 있습니다.

그래서 다음과 같은 문제점을 생각할 수 있습니다.

- 설계 제약 사항 증가

  - 서비스 간 호출 시 API를 사용하기 때문에 네트워크 에러가 발생할 수 있고 통신 비용이나, Latency가 그만큼 늘어나게 됩니다.

  - 각 서비스가 다른 서버에 분리 배포되어있기 때문에 서버 URL이 각기 다를 수 밖에 없습니다. 이를 처리하기 위한 **API Gateway**가 필요합니다.

- 테스트 / 트랜잭션
  - 서비스가 분리되어 있기 때문에 테스트와 트랜잭션의 복잡도가 증가하고, 많은 자원을 필요로 합니다.

- 데이터 관리
  - 데이터가 여러 서비스에 걸쳐 분산되기 때문에 한번에 조회하기 어렵고,  데이터의 정합성 또한 관리하기 어렵습니다.

- 개인이 관리해야 할 서비스의 증가

  - 물리적으로 서비스가 늘어나기 때문에 담당 범위가 늘어납니다.

  - 분리된 서비스를 따로 개발하다 보면 기술 스택의 차이가 발생할 수 있습니다.

    

> API Gateway
>
> MSA의 문제점 중 하나는 각 서비스가 다른 서버에 분리 배포되어있기 때문에 서버 URL이 각기 다를 수 밖에 없습니다. 이때 API Gateway는 API 서버 앞 단에서 모든 API 서버들의 End-Point를 단일화하여 묶어주는 역할을 합니다. 또한 거미줄처럼 복잡한 서비스간의 API호출 구조도 단순화 시켜줍니다. 그 외에 라우팅, 로드밸런싱, 인증 역할 등등 여러 역할을 수행합니다.



## MSA는 언제나 유용한가?

MSA는 복잡한 웹 시스템에 맞춰 개발된 API기반의 서비스 지향적 아키텍처 스타일입니다. MSA가 유행을 하고 있지만 꼭 정답은 아닙니다. 아키텍처 모델에 따라 시스템에 대한 설계뿐만 아니라 팀의 구조나 프로젝트 관리 방법까지 달라지기 때문에 업무나 비즈니스 특징에 따라 적절한 아키텍처가 선택되어야 합니다. 

- Monolithic Architecture 프로젝트의 팀 예시

<p align="center"><img src="img/MSA_team1.png" width="600"></p>



- Microservices Architecture 프로젝트의 팀 예시

<p align="center"><img src="img/MSA_team2.png" width="600"></p>

MSA가 서비스의 재사용 성, 유연한 아키텍처구조, 대용량 웹 서비스에 적합한 구조 등 많은 장점을 가지고 있지만 개개인의 높은 숙련도가 필요한 편입니다. 프로젝트의 목적이나 팀의 상황에 맞는 유연한 선택이 필요합니다.



#### Reference

https://www.redhat.com/ko/topics/microservices/what-are-microservices

https://tech.kakao.com/2021/09/14/msa/

https://wonit.tistory.com/487

http://clipsoft.co.kr/wp/blog/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98msa-%EA%B0%9C%EB%85%90/

https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e

------

# OOP
## OOP(Object Oriented Programming)란?
OOP란 **객체 지향 프로그래밍** 즉, 절차 지향 프로그래밍이 아닌 **객체의 관점에서 프로그래밍을 한다**는 것이다.

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/135736422-094ace69-8c9f-44c1-b0da-3fb2f06cecf9.png" width="30%">
<img src="https://user-images.githubusercontent.com/33649908/135736432-e2ec8e61-d2be-4062-a0cc-417d22f53840.png" width="34%">
</p>

프로그래밍에서 필요한 데이터를 **추상화**시켜 상태와 행위를 가진 **객체**를 만들고 그 객체들 간의 유기적인 **상호작용을 통해 로직을 구성**하는 프로그래밍 방법이다.

<br>

### 절차 지향 프로그래밍 VS 객체 지향 프로그래밍
* **절차 지향 프로그래밍**
  * 물이 위에서 아래로 흐르는 것처럼 **순차적인 처리**를 중요시하는 프로그래밍 기법이다.
  * 가장 대표적인 언어로 **C언어**가 있다.
  * 컴퓨터의 처리구조와 유사해 **실행속도가 빠르다.**
  * 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

* **객체 지향 프로그래밍**
  * 실제 세계의 사물들을 **객체로 모델링**하여 개발을 진행하는 프로그래밍 기법
  * 가장 대표적인 언어로 **C++, Java**가 있다.
  * 캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다.
  * 절차 지향 언어보다 **실행속도가 느리다.**

<br>

## OOP의 기본 구성 요소
<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/135737142-36058eb8-198f-45f9-b7e6-e6c513ed26d9.png" width="40%">
</p>

> 붕어빵 틀 = **클래스**, 붕어빵의 실체 = **인스턴스**, 붕어빵 한 마리 = **객체**, 굽기() = **인스턴스화**

<br>

### 클래스(Class)
* 개념
  * 객체를 만들어 내기 위한 설계도 혹은 틀
  * 연관되어 있는 `변수(상태)`와 `메소드(행위)`의 집합

### 객체(Object)
* 개념
  * 소프트웨어에서 구현할 대상
  * 클래스에 선언된 모양 그대로 생성된 실체

* 특징
  * **‘클래스의 인스턴스(instance)’** 라고도 부른다.
  * 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
  * OOP의 관점에서 클래스의 타입으로 선언되었을 때 **‘객체’** 라고 부른다.

### 인스턴스(Instance)
* 개념
  * 설계도를 바탕으로 소프트웨어에 구현된 구체적인 실체
  * 즉, 객체를 소프트웨어에 실체화하면 그것을 **‘인스턴스’** 라고 부른다.
  * 실체화된 인스턴스는 메모리에 할당된다.

* 특징
  * 인스턴스는 객체에 포함된다고 볼 수 있다.
  * OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 **‘인스턴스’** 라고 부른다.
  * 인스턴스는 어떤 원본(추상적인 개념)으로부터 **‘생성된 복제본’** 을 의미한다.

<br>

## OOP의 장/단점
### 장점 👍
* **코드 재사용이 용이하다.**
  * 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다.

* **유지보수가 쉽다.**
  * 절차 지향 프로그래밍에서는 코드를 수정할 때 일일이 찾아 수정해야하는 반면, 
  * 객체 지향 프로그래밍에서는 수정할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 된다. 

* **대형 프로젝트에 적합하다.**
  * 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러 회사에서 개발이 필요할 시 업무 분담하기 쉽다.

### 단점 👎
* **처리속도가 절차 지향 프로그래밍에 비해 상대적으로 느리다.**

* **객체가 많으면 용량이 커질 수 있다.**

* **설계시 많은 시간과 노력이 필요하다.**

<br>

## OOP의 특징
1. 추상화 (Abstraction)
2. 캡슐화 (Encapsulation)
3. 상속(재사용성) (Inheritance)
4. 다형성 (Polymorphism)

<br>

## 1. 추상화
어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/33649908/135737545-88fe60df-57a8-4bbd-bca6-0fbfe5726085.png" width="60%">
</p>

* `인터페이스`와 `구현`을 분리함으로써, 객체가 가진 특성 중 필수 속성만으로 객체를 묘사하고 유사성만을 표현하며 세부적인 상세 사항은 각 객체에 따라 다르게 구현되도록 할 수 있다.
* Java에서는 **인터페이스**, **추상클래스**를 활용할 수 있다.

<br>

### 인터페이스
* 클래스의 템플릿, 껍데기만 있는 클래스라 할 수 있다.
* 인터페이스는 멤버 변수, 멤버 함수를 가질 수 없고, **추상 메소드와 상수**만 가질 수 있다.
* 여러 클래스의 사용 방법이 같음을 보장한다.
* 인터페이스를 구현하는 구체 클래스에서 **추상 메소드들을 모두 구현**해주어야 한다.
* 인터페이스는 **다중 상속**이 가능하고, **인터페이스끼리 상속이 가능**하다.

### 추상 클래스
* **추상 메소드를 하나 이상 가진 클래스**이다.
* 하위 클래스를 참조하여 상위 클래스의 객체를 생성하며, 하위 클래스를 제어하기 위해 사용한다.
* 추상 클래스의 생성자로 **객체 생성이 불가**하다.

<br>

## 2. 캡슐화
하나의 객체에 대해 그 객체가 **특정한 목적을 위한 필요한 변수나 메소드를 하나로 묶는 것**

따라서 클래스를 만들 때 사용할 **변수**와 그 변수를 가지고 특정한 액션, 즉 **메소드**를 관련성 있게 클래스에 구성해야한다.

<br>

### 정보은닉
* 캡슐화를 하는 중요한 목적은 바로 **정보은닉**이다.
  
* 유저 정보를 가지고 있는 User라는 객체에서 유저의 정보가 `public`으로 선언되어 있다면, 누구든 접근해서 유저 정보를 변경할 수 있다.
  
* 그렇기 때문에 `private`로 해서 데이터를 보호해서 접근을 제한해야한다.
  
* 이렇게 보호된 변수는 **getter**나 **setter** 등의 메서드를 통해서만 간접적으로 접근이 가능하도록 하는 것이 캡슐화의 중요한 목적이다.

<br>

### 정보은닉이 왜 필요할까?
* **높은 응집도**와 **낮은 결합도**를 유지할 수 있도록 설계하여 요구사항을 변경할 때 유연하게 대처하기 위해서
  
* 한 클래스가 변경이 발생하면 변경된 클래스에 의존하는 다른 클래스들도 변경해야 할 가능성이 커지기 때문이다.

> **응집도**(Cohesion) : 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다. <br>
> **결합도**(Coupling) : 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타낸다.

<br>
  
**캡슐화** -> **정보은닉** (private, getter, setter) -> **높은 응집도, 낮은 결합도**

<br>

## 3. 상속
상속이란 기존 상위 클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념이다.

기존 클래스에 기능을 가져와 **재사용**할 수 있으면서도 동시에 새롭게 만든 클래스에 **새로운 기능을 추가**할 수 있게 만들어 준다.

<br>

### 상속의 장점 👍
* 상위 클래스를 재사용해서 하위 클래스를 빨리 개발할 수 있도록 한다.

* 반복된 코드의 중복을 줄여준다.

* 유지 보수의 편리성을 제공해 준다.

* 객체의 다형성을 구현할 수 있다.

### 상속의 단점 👎
* 상위 클래스의 변경이 어려워진다.
  * 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경을 자식 클래스에게 많은 영향을 끼친다.

* 불필요한 클래스가 증가할 수 있다.
  * 유사 기능 확장 시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.

* 상속이 잘못 사용될 수 있다.
  * 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면 문제가 발생할 수 있다.
  * 상속받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 이에 해당한다.

<br>

### 해결책
1. 객체 조립(컴포지션)을 사용한다.
    * 필드에서 다른 객체를 참조하는 방식으로 구현된다.

2. 상속은 IS-A 관계가 성립하고, 재사용 관점이 아닌 기능의 확장 관점일 때 사용한다.

<br>

## 4. 다형성
다형성은 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해준다.

* 즉, 다형성은 형태가 같은데 다른 기능을 하는 것을 의미한다.

* 이를 통해 코드의 재사용, 코드 길이 감소가 되어 유지보수가 용이하도록 도와준다.

다형성을 구현하는 방법은 대표적으로 **오버로딩**, **오버라이딩**이 있다.

<br>

### 오버로딩 (Overloading)
같은 이름의 메소드를 사용하지만 메소드마다 다른 용도로 사용되며 그 결과물도 다르게 구현할 수 있게 만드는 개념

오버로딩이 가능하려면 **메소드끼리 이름은 같지만 매개변수의 갯수나 데이터 타입이 다르면** 오버로딩이 적용
* _매개 변수는 같고, 리턴 타입이 다를 때는 성립하지 않는다._

<br>

``` java
public class OverloadingTest{
  
  public void test(){
    System.out.println("사용자 없음");
  }
  
  public void test(String name){
    System.out.println("사용자 이름 = " +name);
  }
  
  public void test(String name, int money){
    System.out.println("사용자 이름 = "+name+" , 사용료 = "+money);
  }
  
  // 리턴 타입이 다르므로 오버로딩 적용 X
  public String test(String name){
    System.out.println("사용자 이름 = " +name);
    return name;
  }
}
```

<br>

### 오버라이딩 (Overriding)
부모 클래스에서 상속받은 자식 클래스에서 부모클래스에서 만들어진 메소드를 **자식 클래스에서 다시 재정의해서 사용하는 것**을 말한다.

``` java
public class Employee{
  
  public String name;
  public int age;
  
  public void print(){
    System.out.println("사원의 이름 = "+this.name+", 나이 = "+this.age);
  }
}

// Emplyee 상속
public class Manager extends Employee{
  
  String jobOfManage;
  
  // Employee의 print() 메소드 오버라이딩
  public void print(){
    System.out.println("사원의 이름 = "+this.name+", 나이 = "+this.age);
    System.out.println("관리자 "+this.name+"은 "+this.jobOfManage+" 담당입니다.");
  }
}
```

<br>

----

# OOP의 5가지 설계 원칙

SOLID

- [SRP(단일 책임 원칙)](#srp)
- [OCP(개방 폐쇄 원칙)](#ocp)
- [LSP(리스코프 치환 원칙)](#lsp)
- [ISP(인터페이스 분리 원칙)](#isp)
- [DIP(의존관계 역전 원칙)](#dip)

디자인 패턴이 특별한 상황에서 발생하는 문제에대한 구체적인 솔루션이라면

객체지향 설계원칙은 좀 더 일반적인 상황에서 적용가능한 설계기준입니다.

객체지향의 5가지 원칙을 지키면 객체지향의 가장 큰 장점을 극대화 할 수 있습니다.

## SRP

단일 책임 원칙

"한 클래스는 하나의 책임만을 가져야한다"는 원칙입니다.

예를들면 커뮤니티 사이트에서 회원 정보를 관리할 때, 회원의 정보와 회원이 작성한 게시글에대한 정보까지 하나의 클래스에서 관리하면 게시글에대한 변경사항이 있을 때, 회원 클래스를 수정해야합니다.

이처럼 변경사항이 있을 때, 그 변경에대해서 그와 관련된 부분만 수정할 수 있도록 설계해야한다는 원칙이 단일 책임 원칙입니다.

단일 책임 원칙에서 가장 중요한 것은 각각의 클래스가 가지는 책임의 범위를 적절하게 잘 조절하는 것입니다.

## OCP

개방 폐쇄 원칙

"확장에는 열려있고 변경에는 닫혀있다."는 원칙입니다.

여기서 확장과 변경의 의미는 다음과 같습니다.

확장 - 기능을 변경하거나 확장하는 것을 의미

변경 - 확장된 기능을 사용하는 코드를 수정하는 것을 의미

다형성을 활용해서 인터페이스를 구현한 새로운 클래스를 만들고 거기에 새로운 기능을 구현해주는 방식입니다.

예를들면, 게시판에 업로드를 하는 부분에대한 기능의 확장이 있을 때, 업로드 기능을 사용하는 부분에서는 기존에 사용하던 방식을 그대로 사용할 수 있도록 하는 것을 의미합니다.

하지만, 구현 객체를 변경하려면 클라이언트 코드를 변경해야하기 때문에, 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요합니다. 

→ 이 과정을 스프링이 대신 해줍니다^^

## LSP

리스코프 치환 원칙

"인터페이스를 구현한 구현체 즉, 하위 클래스는 인터페이스의 규약을 다 지켜야한다."는 원칙입니다.

인터페이스를 구현한 구현체의 신뢰성을 올리기위한 원칙으로 상위 타입의 객체를 하위 타입의 객체로 형변환 해도 정상적으로 작동할 수 있도록 하기 위해서 적용합니다.

## ISP

인터페이스 분리 원칙

"인터페이스의 기능을 적당한 크기로 나눠서 인터페이스를 더 명확하고 대체 가능성을 높여야한다"는 원칙입니다.

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 좋다는 의미입니다.

예를 들면, 커뮤니티 사이트에서 북마크 기능을 개발할 때, 회원 북마크 기능과 게시글 북마크 기능을 개발을 할 때, 북마크 기능 전체에대한 범용 인터페이스보다는 회원 북마크용 인터페이스와 게시글 북마크용 인터페이스를 만들어두는게 좋습니다. 

## DIP

의존관계 역전 원칙

"추상화에 의존해야지, 구체화에 의존하면 안된다."라는 원칙입니다.

의존성 주입은 이 원칙을 따르는 방법 중 하나입니다. 

OCP와 연관이 있는 원칙입니다.

클라이언트 코드가 구현 클래스가 아닌 인터페이스를 바라보게해서, 인터페이스에서 어떤 구현 클래스를 사용할지 선택하게 하는 방식입니다.

이런 방식으로 개발해야하는 이유는 역할에 의존하지않고 구현에 해당하는 구현체에 의존하게되면 변경시에 불필요한 코드 수정이 많이 발생하기 때문입니다.

OCP와 마찬가지로 다형성만으로는 구현 객체를 변경할 때, 클라이언트 코드도 변경해야하기 때문에 DIP를 지키기 어렵습니다. 

→ 그래서 스프링이 필요합니다!

<hr>

# 동기vs비동기

## 동기

> 요청을 보냈을 경우 응답이 돌아올 때까지 기다리는 방식

- 요청을 보낸 스레드는 응답이 돌아올 때까지 기다리고 있고 다른 스레드는 어떠한 작업도 처리하지 않는다.

- 요청을 보내고 응답을 받는 방식으로 진행되기 때문에 프로그램이 순차적으로 수행된다.

- 순차적인 수행으로 코드 간 시간 순서 관계가 있다.

### 장점
- 설계가 간단하다.
- 순차적으로 코드가 실행되기 때문에 로직을 파악하기 쉽다.

### 단점
- 응답이 돌아올 때까지 아무런 작업을 하지 못하고 대기해야 한다.

## 비동기

> 요청을 보내도 응답을 기다리지 않고 작업을 계속 수행하는 방식

- 요청을 보낸 스레드는 응답이 돌아올 때까지 멈춰있지만 다른 스레드는 작업을 계속 이어나간다.

- 동기와 달리 프로그램의 수행이 순차적이지 않다.

- 보통 비동기 개념이 필요한 경우 서버와의 통신(네트워크 작업)을 위해 사용한다.

### 장점
- 요청 후에 다른 작업을 할 수 있기 때문에 자원을 효율적으로 사용할 수 있다.

### 단점
- 동기와 다르게 설계가 복잡하다.

<hr>

# 도커란?

도커는 **'컨테이너 기반의 오픈소스 가상화 플랫폼'**
- 도커로 컨테이너를 띄운다.
- 컨테이너란?<br>
  애플리케이션 & 애플리케이션을 구동하는 환경을 격리한 공간<br>
  컨테이너에 프로그램을 띄워서 돌린다고 생각하면 된다.<br>
  보통 마이크로 서비스로 사용된다.<br>
    - 거대한 어플리케이션을 기능별로 나누어 변경/조합이 가능하게 한 것
    - 컨테이너를 사용하면 하나의 큰 어플을 서비스 단위로 잘라 빠르게 배포 가능.
    - 그리고 각각 분리해서 쓰니 변경사항이 분리된 다른 기능들에 영향 미치지 않음.

<br>

**기존의 가상머신(VM)과 컨테이너의 차이점**
<p align="center">
<img src="https://user-images.githubusercontent.com/67310666/127528645-e66d5480-6ab2-4816-8e59-4030f489b077.png" width="90%">
</p>

- 기존의 가상머신(VM) 서버
    - Server -> Hypervisor -> 각각의 Guest OS가 설치된 VM 구동
    - 가상 머신의 모든 자원을 사용
- 컨테이너 서버 <br>
    - Server -> Host OS -> Docker Engine -> Container 올리기
    - CPU, RAM, Disk, Network와 같은 운영체제의 자원을 필요한 만큼 컨테이너에 할당
    - 효율적!! 배포가 빠름!! but 컨테이너 하나가 자원을 많이 사용하면 장애 발생.
- 도커가 가진 컨테이너는 독립적이고 동적이다.
    - if, 당신의 app이 인기가 많아지면 그 컨테이너의 수를 늘리고, 다시 트래픽이 줄면 해당 컨테이너 수를 줄이면 된다. 
    - 즉, 도커 덕분에 매번 새로운 서비스를 만들 때마다 새로운 서비스를 사고, 설정할 필요가 없음
    - 하나의 같은 서버에 각기 다른 환경의 컨테이너를 설정할 수 있고, 이 컨테이너들은 각각 분리, 독립되어 있는 것이기 때문에 더욱 효율적
    <br>

```
쉽게 말하자면!
가상 컴퓨팅은 한 물리적 컴퓨터 안에 각각 OS를 가동하는 가상 컴퓨터들이 물리적 자원을 분할해서 쓰기 때문에 성능에 한계가 있음!
도커는 OS단까지 내려가는게 아니라 실행 환경만 독립적으로 돌리는 거라서 컴퓨터에 직접 요소들을 설치한거랑 별 차이 없는 성능을 낼 수 있음!
```
<br>

Youtube ["도커가 뭐고 왜 쓰는건가요?"](https://youtu.be/tPjpcsgxgWc)

<br>

# 쿠버네티스란?
<p align="center">
<img src="https://user-images.githubusercontent.com/67310666/128356721-8d8fc51a-eaf7-42b8-be50-5bbecd205523.png" width="50%">
</p>

쿠퍼네티스는 **'컨테이너 오케스트레이션 툴'**
- 오케스트레이션이란?<br>
컨테이너 수가 많아지면 관리와 운영에 있어 어려움이 있음. <br>
이러한 다수의 컨테이너 실행을 관리 및 조율하는 시스템.
오케스트레이션 엔진을 통해 컨테이너의 생성과 소멸, 시작 및 중단 시점 제어, 스케줄링, 로드 밸런싱, 클러스터링 등 컨테이너로 어플리케이션을 구성하는 모든 과정을 관리할 수 있음.

