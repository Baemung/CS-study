# Operating System(OS) 운영체제

1. 운영체제란?
2. 프로세스와 쓰레드
3. 인터럽트
4. 시스템 콜
5. PCB와 Context Switching
6. IPC
7. CPU 스케줄링
8. [Deadlock 교착상태](#Deadlock-교착상태)
9. Race Condition
10. 세마포어
11. 뮤텍스
12. 페이징 & 세그멘테이션
13. 페이지 교체 알고리즘
14. 메모리 & 가상 메모리
15. 파일 시스템





# Deadlock 교착상태

## 교착상태란?

한 프로세스 집합 내의 모든 프로세스가 그 집합 내의 다른 프로세스에 의해서만 발생될 수 있는 사건을 기다리는 상황이 발생하여, 프로세스들이 모두 무한정 대기에 빠지는 것을 말합니다.

> 예를 들어봅시다. 프로세스는 자원을 사용하기 위해 **요청**, **사용**, **방출** 순서를 지켜야합니다.  
> 3개의 CD RW 드라이브를 가진 시스템에서 3개의 프로세스가 각각의 CD RW 드라이브를 사용하고 있는 상태라고 가정합니다. 만약 이 상황에서 3개의 프로세스가 또 다른 드라이브를 요청할 경우, 세 프로세스는 교착상태에 빠지게 됩니다. 모든 프로세스는 다른 대기중인 프로세스에 의해 드라이브가 방출되어야지만 대기에서 빠져나올 수 있기때문입니다.

## 교착상태의 특징

### 교착상태 발생의 필요 조건

교착상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있습니다.

1. 상호 배제(Mutual exclusion)
    - 최소한 하나의 자원이 비공유 모드(하나의 자원은 한 번에 한 프로세스만 사용할 수 있음)로 점유되어야 합니다.
    - 다른 프로세스가 그 자원을 요청할 경우, 요청 프로세스는 자원이 방출될 때까지 대기해야 합니다.
2. 점유하며 대기(Hold-and-wait)
    - 프로세스는 최소한 하나의 자원을 점유한 상태로, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기해야 반드시 합니다.
3. 비선점(No preemption)
    - 자원이 강제적으로 방출될 수 없습니다.
    - 점유하고 있는 프로세스가 태스크를 종료한 후 그 프로세스에 의해 자발적으로만 방출될 수 있습니다.
4. 순환 대기(Circular wait)
    - 대기하고 있는 프로세스 집합 {p0, p1, ..., pn}에서 p0은 p1이 점유한 자원을 대기하고, p1은 p2가 점유한 자원을 대기하고, pn은 p0이 점유한 자원을 대기하는 것과 같은 상황입니다.
    - 즉, 대기하는 방향이 순환하는 형태입니다.

### 자원 할당 그래프(Resource-Allocation Graph)

교착상태는 정점(vertex, V)과 간선(edge, E) 집합으로 표현할 수 있습니다.

![resource-allocation-graph](resource-allocation-graph1.png)

- 정점
    - 시스템 내의 모든 활성 프로세스(원으로 표현)
    - 시스템 내의 모든 자원 유형(사각형으로 표현)
- 간선
    - 프로세스의 자원 요청 관계(프로세스에서 자원으로의 화살표로 표현)
    - 자원의 프로세스 할당 관계(자원에서 프로세스로의 화살표로 표현)

![resource-allocation-graph](resource-allocation-graph2.png)

## 교착상태 처리 방법

원칙적으로 교착상태 문제를 처리하는 데에는 다음과 같은 세 가지 방법이 존재합니다.

- 시스템이 교착상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 이용합니다.
- 시스템이 교착상태가 되도록 허용한 다음 회복시킵니다.
- 문제를 무시하고, 교착상태가 시스템에서 발생하지 않은 척 합니다.

놀랍게도 UNIX와 Windows를 비롯한 대부분의 운영체제는 세 번째 방법을 사용합니다. 이는 드물게 발생하는 교착상태에 대해 처리 비용과 오버헤드가 큰 교착상태 예방, 회피 및 탐지, 복구 알고리즘을 적용하는 것보다 수작업으로 시스템을 중지하고 재시작하는 것이 더 낫다고 판단하기 때문입니다.

### 교착상태 예방(Deadlock Prevention)

교착상태를 예방하기 위해서는 앞서 언급한 4가지의 교착 상태 발생 필요 조건 중 적어도 하나가 성립하지 않도록 보장해야 합니다.

1. 상호 배제

상호 배제 조건은 공유가 불가능한 자원에 대해서는 반드시 성립해야 합니다. 따라서 근본적으로 동시 접근을 허용할 수 없는 자원이라면 상호배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능합니다.

2. 점유하며 대기

점유하며 대기 조건의 성립을 막기 위해, 프로세스가 자원을 요청할 때는 다른 자원들을 점유하지 않을 것을 보장해야 합니다. 이를 위한 방법으로는 2가지가 존재합니다.

- 프로세스가 실행되기 전 자신이 필요로하는 모든 자원을 최초에 한 번에 요청하고 할당받습니다.
- 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용합니다.

> 예를 들어봅시다. DVD 드라이브로부터 자료를 받아 디스크 파일로 저장하고 이를 프린터로 출력하는 프로세스가 존재합니다. 전자의 방법을 적용할 경우 프로세스는 초기에 DVD 드라이브, 디스크 파일, 프린터를 요청해야 합니다. 후자의 방법을 적용할 경우 프로세스는 DVD 드라이브, 디스크 파일을 먼저 요청하여 사용한 뒤 이를 방출하고 나서 프린터를 요청하고 사용할 수 있습니다.

두 방법에는 모두 단점이 존재합니다. 전자의 경우 많은 자원들이 한꺼번에 할당된 후 오랜 기간 동안 사용되지 않고 점유될 수 있기때문에 **자원의 이용도가 낮을 수 있습니다**. 후자의 경우 자신이 필요한 자원 중 최소 하나 이상이 항상 다른 프로세스에게 할당되어 있기 때문에 **기아 상태**에 빠질 수 있습니다.

3. 비선점

비선점 조건의 성립을 막기 위해서는, 어떤 자원을 점유하고 있는 프로세스가 다른 자원을 요청했지만 해당 자원을 당장 프로세스에게 할당할 수 없는 경우(즉, 대기가 발생할 경우) 프로세스가 원래 점유하고 있던 자원이 선점될 수 있도록 합니다.

4. 순환 대기

순환 대기 조건의 성립을 막기 위해서는, 모든 자원 유형들에게 순서를 부여하여 프로세스가 열거된 순서대로 자원을 요청하도록 요구해야 합니다.

### 교착상태 회피(Deadlock Avoidance)

위의 방법들로 교착상태를 예방할 수 있지만, 장치 이용률이 저하되고 시스템 처리율이 감소된다는 한계가 존재합니다.

다른 접근으로는 **프로세스가 일생 동안 요청하고 사용할 자원에 대한 정보를 사전에 제공받아, 교착상태를 미리 예측**하는 방법이 있습니다. 이를 위해서는 현재 가용 자원, 현재 각 프로세스에게 할당된 자원, 각 프로세스가 앞으로 요청하거나 방출할 자원을 고려해야 합니다.

2가지의 교착상태 회피 알고리즘이 존재합니다. 이 알고리즘을 통해 시스템 **안전 상태**(프로세스들이 요청하는 모든 자원을 교착 상태를 발생시키지 않고 할당해줌)를 판단할 수 있습니다. 시스템이 불안전 상태라고 할지라도 교착상태에 빠지지 않을 수 있지만, 교착상태에 빠진다면 불안전 상태에 존재하게 됩니다. 따라서 시스템을 안전 상태로 유지한다면 교착상태를 예방할 수 있습니다.

#### 자원 할당 그래프 알고리즘

시스템의 각 자원 유형 별로 *단 하나의 인스턴스*만 존재하는 경우 자원 할당 그래프를 조금 변형시켜 교착 상태를 예견할 수 있습니다.

요청 간선과 할당 간선에 **예약 간선**이라는 새로운 유형을 도입합니다. 예약 간선은 프로세스가 미래에 해당 자원을 요청할 것이라는 의미를 내포합니다. 따라서 프로세스 실행 전 모든 예약 간선을 자원 할당 그래프에 명시해둔다면 교착 상태가 발생할 것을 사전에 예측할 수 있습니다.

![resource-allocation-graph-algorithm](resource-allocation-graph-algorithm.png)

예약 간선을 할당 간선으로 변환시켜도 자원 할당 그래프에 사이클이 형성되지 않을 때에만 자원을 할당한다면 교착 상태가 발생하는 것을 피할 수 있습니다.

#### 은행원 알고리즘(Banker's Algorithm)

시스템의 각 자원 유형 별로 *여러개의 인스턴스*가 존재하는 경우 적용할 수 있는 알고리즘입니다.

이름에서 볼 수 있듯이 은행에서 돈을 빌리려는 다수의 고객이 존재할 때, 은행이 파산하지 않고 모든 고객에게 돈을 빌려주는 원리를 이용합니다.

> 예를 들어 봅시다. 100달러를 보유하고 있는 은행에 3명의 고객이 찾아와 각각 60달러, 40달러, 50달러씩 대출하기를 신청했습니다.
> 은행은 먼저 고객1에게는 20달러를, 고객2와 고객3에게는 30달러씩 빌려줍니다. 은행은 수중에 20달러가 남습니다.
> 이후 고객2에게 남은 10달러를 빌려주고 기다립니다. 고객2가 40달러를 상환하면 은행은 수중에 50달러가 남습니다.
> 이후 고객1에게 남은 40달러를 빌려주고 기다립니다. 고객1이 60달러를 상환하면 은행은 수중에 70달러가 남습니다.
> 이후 고객3에게 남은 20달러를 빌려주고 기다립니다. 고객3이 50달러를 상환하면 은행은 파산하지 않고 모든 고객게에 돈을 빌려줄 수 있습니다.
> 하지만 3번째 단계에서 은행이 고객1에게 남은 20달러를 모두 빌려줬다면 고객 중 상환할 수 있는 사람은 없고, 모두 대출을 받기 위해 기다려야 하는 상태에 빠지게 되어 파산하게 됩니다. -> 교착상태

이 방법과 같이 시스템은 **프로세스의 자원 요청을 허가**했을 때 시스템이 **안전 상태에 머무른다면 요청을 들어주고** 그렇지 않다면 프로세스를 대기시킵니다. 안전 상태에서 머무를 수 있도록 하는 안전 순서열이 존재한다면 시스템의 교착상태를 막을 수 있습니다.

이를 구현하기 위해 다음과 같은 자료구조가 필요합니다

- 가용(Available) : 각 종류의 자원이 현재 몇 개가 가용한지 나타내는 벡터
    - `Available[j] = k` : 현재 Rj를 k개 사용할 수 있음
- 최대(Max) : 각 프로세스가 최대로 필요로하는 자원의 개수를 나타내는 행렬
    - `Max[i, j] = k` : Pi가 Rj를 최대 k개 요청할 수 있음
- 할당(Allocation) : 각 프로세스에게 현재 할당되어 있는 자원의 개수를 나타내는 행렬
    - `Allocation[i,j] = k` : 현재 Pi가 Rj를 k개 사용하고 있음
- 요구(Need) : 각 프로세스가 향후 요구할 수 있는 자원의 개수를 나타내는 행렬
    - `Need[i,j] = k` : 향후 Pi가 Rj를 k개까지 요청할 수 있음
    - `Max[i, j] - Allocation[i,j] = Need[i,j]`

##### 안정성 알고리즘(Safty Algorithm)

시스템이 안전한지 판단하는 알고리즘 입니다. n은 프로세스 수를, m은 자원 종류의 수를 나타냅니다.

1. Work(향후 사용 가능한 자원 수)와 Finish(자원을 모두 사용하여 작업이 끝난 프로세스 수)는 각각 크기가 m과 n인 벡터이다. Work = Available로 초기화한다. 프로세스의 번호를 나타내는 i를 대상으로 Finish[i] = false로 초기화한다.
2. 두 조건을 만족시키는 i를 찾는다. 만약 그러한 i를 찾지 못하면 step 4로 간다.
    - Finish[i] == false
    - Needi <= Work
3. 아래 두 연산을 수행하고 step 2로 간다.
    - Work = Work + Allocationi
    - Finish[i] = true
4. 모든 i에 대해 Finish[i] == true이면 이 시스템은 안전 상태에 있다.

![banker's-algorithm](banker's-algorithm.png)

### 교착 상태 탐지(Deadlock Detection)

시스템이 교착상태 예방이나 교착상태 방지 알고리즘을 사용하지 않는다면 결국에는 교착상태가 발생하게 됩니다. 이러한 환경에서는 교착상태가 발생했는지 확인하기 위한 시스템 상태 검사 알고리즘과 교착 상태로부터 회복하는 알고리즘이 필요합니다.

교착상태 탐지는 자원 유형 별 개수에 따라 다른 방법을 적용합니다.

1. 자원 유형이 한 개씩 있는 경우

자원 할당 그래프를 변형시킨 대기 그래프를 활용하여 교착상태를 탐지할 수 있습니다. 대기 그래프가 사이클을 포함할 경우 시스템에 교착상태가 존재한다고 판단할 수 있습니다.

![wait-for-graph](wait-for-graph.png)

2. 자원 유형 별 자원이 여러개 있는 경우

교착상태 회피 알고리즘의 은행원 알고리즘과 유사합니다. 가용(Available), 할당(Allocation), 요청(Request) 자료구조를 이용하여 모든 프로세스가 요구하는 자원을 충족시켜줄 안전 순서열이 존재하는지 여부를 파악합니다.

**교착상태 발생 빈도**와 **교착상태 발생 시 몇 개의 프로세스가 연루되는지**에 따라 교착상태 탐지 알고리즘을 실행시킬 수 있습니다. 프로세스의 요청이 즉시 만족되지 않을 때마다 탐지 알고리즘을 실행시킨다면, 교착상태를 야기한 프로세스를 파악할 수 있지만 오버헤드가 크게 발생할 수 있다는 딜레마가 존재합니다.

### 교착 상태로부터 회복

교착상태에서 빠져나오기 위해 시스템은 두 가지 방법을 시도할 수 있습니다. 첫 번째 방법은 프로세스를 중지시킴으로써 순환 대기를 깨뜨리는 것이고, 두 번째 방법은 프로세스로부터 자원을 선점하는 것입니다.

한가지 중요한 것은 탐지와 회복 과정에서 이러한 알고리즘을 실행시키기 위한 비용 뿐만 아니라, 교착상태가 발생했을 때 부가적으로 나타나는 손실을 고려해야 한다는 것입니다.

#### 프로세스 종료(Process Termination)

- 교착상태의 프로세스들을 모두 중지
    - 프로세스가 그동안 연산한 내용이 모두 폐기되므로 비용이 큼
- 교착상태에서 빠져나올 때까지 한 프로세스씩 중지
    - 각 프로세스가 중지될 때마다 교착 상태 탐지 알고리즘을 호출해야 하므로 오버헤드가 유발됨

프로세스를 중간에 중지시키는 것은 결코 쉬운 방법은 아닙니다. 프로세스가 작업하던 파일을 손상시킬 수도 있고, 또 어떤 프로세스를 중지시킬 지 결정하는 데에도 비용이 들어갑니다.

#### 자원 선점(Resource Preemption)

교착상태를 해결하기 위해 선점을 할경우 **희생자를 선택**해야 하고, **롤백 상태를 선택**해야 하며, **기아 상태**가 발생하지 않도록 해야합니다.

## 결론

다양한 교착상태 방지 기법이 존재하지만 어떤 방법도 단독으로 사용하기에는 한계가 존재합니다. 따라서 최적의 해결책을 선택하기 위해서는 위의 기본 방법들을 적절하게 조합하여 사용해야 합니다.
