# Operating System(OS) 운영체제

1. [운영체제란?](#운영체제란)
2. [프로세스와 쓰레드](#프로세스와 쓰레드(Process & Thread))
3. [인터럽트](# 인터럽트 (Interrupt))
4. 시스템 콜
5. PCB와 Context Switching
6. IPC
7. [CPU 스케줄링](#CPU 스케줄링 (CPU Scheduling))
8. [Deadlock 교착상태](#Deadlock-교착상태)
9. Race Condition
10. 세마포어
11. 뮤텍스
12. 페이징 & 세그멘테이션
13. 페이지 교체 알고리즘
14. 메모리 & 가상 메모리
15. 파일 시스템

<br>
# 운영체제란?

운영체제(Operating System)는 컴퓨터 **시스템 자원들을 효율적으로 관리**하여 사용자의 편의성과 시스템 성능을 극대화하는 시스템 소프트웨어 입니다.

컴퓨터 사용자와 컴퓨터 하드웨어 간의 **인터페이스로 동작**합니다.

응용프로그램은 운영체제가 제공하는 자원만을 사용할 수 있습니다.


<p align="center"><img src="./img/os.png" width="400"></p>


## 부팅(Booting)

운영체제는 다음의 순서로 실행됩니다.

<p align="center"><img src="./img/os-booting.png" width="1000"></p>

1. 컴퓨터의 전원이 켜진다.
2. 프로세서(CPU)에서 ROM에 있는 내용을 읽는다.
   - ROM 안에는 POST(Power-On Self-Test), 부트 로더(boot loader)가 저장되어 있다.
3. POST는 현재 컴퓨터의 상태를 검사한다.
4. 부트 로더가 실행되어 하드디스크에 저장되어 있는 운영체제를 찾아서 RAM에 가지고 온다.



## Shell 과 Kernel

운영체제는 크게 셸과 커널로 나누어집니다.

<p align="center"><img src="./img/os-shell-kernel.png" width="1000"></p>

셸(Shell)은 명령어 해석기입니다. 사용자의 지시를 해석하여 시스템에 전달하는 인터페이스 역할을 합니다. sh, bash 등이 있습니다.



커널(Kernel)은 운영체제의 핵심 기능을 하는 제어 프로그램입니다. 프로그램이 요청한 처리를 하드웨어에 나누어 처리를 요구합니다. 시스템 콜을 수행하며, 메모리 관리, 프로세스 관리, 파일 시스템 관리, 입출력 관리, 프로세스 간 통신 관리 등의 작업을 수행합니다.

- 프로세스 관리 : 프로세스에 CPU를 분배하고 작업에 필요한 제반 환경 제공
- 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간 제공
- 파일 시스템 관리 : 데이터 저장하고 접근 할 수 있는 인터페이스 제공
- 입출력 관리 : 필요한 입출력 서비스 제공
- 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 제공



# 프로세스와 쓰레드(Process & Thread)

## 프로세스

프로세스(Process)는 운영체제로부터 자원을 할당 받은 작업의 단위입니다. 

프로그램을 실행하면 운영체제는 프로그램 파일을 컴퓨터 메모리 공간에 할당합니다.

즉, 메모리 공간을 할당받아 실행되고 있는 프로그램을 프로세스라고 할 수 있습니다.  

운영체제는 프로세스마다 각각 독립된 메모리 영역을 Code/Data/Stack/Heap 형식으로 할당해줍니다.

Data에는 전역 변수들이 저장되고 Stack에는 함수의 매개변수, return 주소, 로컬 변수와 같은 임시 값들을 저장합니다. heap에는 프로세스 실행 중에 동적으로 할당되는 값들이 저장됩니다. 

<p align="center"><img src="./img/process.png" width="600"></p>

각 프로세스는 별도의 메모리 공간에서 실행되기 때문에 다른 프로세스의 자원에 접근할 수 없으며,

접근하려면 IPC(Inter Process Communication)를 사용해야 합니다.



## 쓰레드

쓰레드(Thread)는 프로세스가 할당 받은 자원을 이용하는 실행 흐름의 단위입니다.

쓰레드는 프로세스의 작업들을 실행 흐름에 따라 분리한 것입니다. 

기본 적으로 프로세스는 최소 1개의 쓰레드를 가지고 있다. 이를 메인 쓰레드라고 합니다.

쓰레드는 프로세스 안에서 존재하는 것이다. 프로세스와 쓰레드를 코드에 비유하면 프로세스는 코드 전체이고 쓰레드는 그 중 main 함수와 같이 함수들이 될 수 있습니다. 

쓰레드는 프로세스 내에서 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유합니다. 

<p align="center"><img src="./img/thread.png" width="600"></p>

그래서 프로세스와 다르게 쓰레드 간의 일부 공간이나 자원을 공유하여 작동합니다.

<p align="center"><img src="./img/Thread-share.png" width="700"></p>



## 멀티 쓰레드

 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 합니다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있습니다.

<br>

#### 스택을 쓰레드마다 독립적으로 할당하는 이유

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간입니다. 

독립적인 실행 흐름을 추가하기 위해서는 독립적인 함수 호출이 가능해야 합니다. 그래서 스택 메모리 공간이 독립적으로 존재해야 합니다.

따라서 쓰레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당합니다.

<br>

#### PC Register 를 쓰레드마다 독립적으로 할당하는 이유

쓰레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 반환합니다.  그래서 PC Register에 쓰레드가 명령어의 어느 부분까지 수행했는지 PC 값을 저장해놓을 필요가 있습니다. 

따라서 PC 레지스터를 독립적으로 할당합니다.



## 멀티 프로세스 VS 멀티 쓰레드

멀티 프로세스는 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 수행하도록 하는 것입니다. 

- 장점
  - 멀티 프로세스는 프로세스 중 하나에 문제가 발생했을 때 그 프로세스 외의 프로세스에 영향이 생기지 않습니다. 
- 단점
  - Context Switching이 발생하면 CPU 레지스터와 캐쉬에 있는 데이터를 모두 리셋해야 하므로 오버헤드가 매우 큽니다.
  - 프로세스는 각각의 독립된 메모리 영역을 할당 받았기 때문에 프로세스 사이의 통신을 위해서는 IPC를 이용해야 합니다. 그리고 

멀티 쓰레드는 하나의 응용 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레가 하나의 작업을 수행하도록 하는 것입니다. 대표적으로 웹 서버가 멀티 쓰레드 응용 프로그램입니다. 많은 운영체제들이 멀티 프로세스를 지원하지만 멀티 쓰레드를 기본으로 합니다. 

- 장점
  - 쓰레드 간 데이터 공유가 가능하므로 데이터를 주고 받는 것이 비교적 수월합니다. 
  - Context Switching이 발생했을 때 stack 영역만 처리하므로 더 적은 오버헤드가 발생합니다. 
  - 더 적은 메모리 영역이 필요하므로 시스템의 자원 소모도 감소할 수 있습니다. 
- 단점
  - 쓰레드 중 하나에 문제가 발생했을 때 전체 프로세스에 영향을 끼치는 단점이 있습니다. 
  - 자원을 공유하기 때문에 **동기화 문제가 발생**할 수 있습니다.

정리하면 멀티 쓰레드는 멀티 프로세스에 비해 자원의 효율성 증대, 처리 비용 감소, 응답 시간 단축의 이점이 있지만 쓰레드에 문제가 생겼을 때 전체 프로세스에 영향이 생긴다는 것과 동기화 문제가 발생할 수 있으므로 이를 적절히 해결해 주어야 한다는 주의점이 있습니다.

<br>



# 인터럽트 (Interrupt)

인터럽트란 프로세서가 프로그램을 실행하고 있을 때, 입출력 장치나 예외상황의 핸들링이 필요할 경우 프로세서에서 실행 중인 프로그램을 멈추고 상황을 처리하도록 하는 명령입니다.

주요 인터럽트로는 CPU 선점형 스케쥴러의 타이머 인터럽트, 입출력 인터럽트, 1/0 연산 인터럽트(Divide-by-Zero Interrupt)과  등이 있습니다.



## 인터럽트 종류

- 하드웨어 인터럽트(=외부 인터럽트)

  - 입출력장치, 타이밍 장치, 전원 등 외부적인 요인에 의해 발생합니다. 
  - ISR 종료 후 대기합니다.

- 소프트웨어 인터럽트(=내부 인터럽트)

  - 소프트웨어가 OS 서비스를 요청하거나 에러를 일으켰을 때 발생합니다. 

  - 파일 읽기/쓰기, 0으로 나누기, Overflow 등이 있습니다.

  - ISR 종료 후 다시 프로그램으로 돌아거나 프로그램을 강제로 종료합니다.

  - **시스템 콜**도 의도적으로 일으킨 예외 인터럽트입니다.

    

## 인터럽트 처리 과정

프로그램 실행 중 인터럽트가 발생하였다면,

<p align="center"><img src="./img/interrupt_process.PNG" width="400"></p>

- CPU는 실행 중이던 명령어를 마치고 인터럽트 라인을 통해 인터럽트가 걸렸음을 인지합니다.

- **인터럽트 벡터**를 읽고 ISR 주소값을 얻어 **ISR(Interrupt Service Routine)**로 점프하여 루틴을 실행합니다.

  - 인터럽트 벡터는 인터럽트 발생시 처리해야 할 ISR의 주소를 인터럽트 별로 보관하고 있는 테이블입니다.

  - ISR은 인터럽트 핸들러라고도 하며 인터럽트를 처리하는 프로그램이며 OS에서 지원합니다. 인터럽트별로 처리해야할 내용이 있습니다.

- ISR에서 동기화를 막기 위해 인터럽트를 금지합니다.

- 프로세서는 현재까지 수행중이었던 상태를 해당 process의 **PCB(Process Control Block)**에 저장합니다.

- PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장합니다.

- 해당 인터럽트를 처리합니다.

- 다 처리하면, 대피시킨 프로세서의 상태를 복원합니다.

- ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제됩니다.

- IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원합니다.



## 인터럽트가 없다면?

입출력 연산은 프로세서의 명령 수행 연산보다 훨씬 느립니다. 예를 들어 프로세서가 입력 장치를 주기적으로 검사하며 신호를 기다린다면(Polling 방식) 그 때 마다 프로세서는 다른 작업을 수행할 수 없기 때문에 프로세서의 오버헤드가 증가하여 시간이 낭비될 것입니다. 하지만, 인터럽트가 입출력 장치의 처리 신호를 보내준다면 프로세서가 다른 작업을 하고 있다가 그 작업을 처리할 수 있게 됩니다.

<br>



# CPU 스케줄링 (CPU Scheduling)

## CPU 스케줄링이란?

단일 처리기 시스템에서는 한 순간에 하나의 프로세스만 실행될 수 있습니다. 즉, 나머지 프로세스는 CPU가 자유상태가 될 때까지 무기한 대기해야 하는 것이죠.

다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행중인 프로세스가 존재하도록 하는 데 있습니다. 따라서 운영체제는 CPU를 점유한 프로세스에 대기가 발생할 때마다 그 프로세스로부터 CPU를 회수하여 다른 프로세스에게 할당하는 스케줄링을 시도합니다.

<br>

## CPU 스케줄링과 관련된 사전 지식

### CPU-입/출력 버스트 사이클(CPU I/O Burst Cycle)

먼저 프로세스가 실행되는 도중 CPU를 사용하지 않아 CPU가 쉬게 되는 상황에 대해 알아봅시다.

프로세스 실행은 **CPU 실행과 입/출력 대기의 사이클**로 구성됩니다. CPU가 필요할 때는 CPU를 집중적으로 사용하다가 입/출력 요청이 발생할 때는 CPU는 잠시 쉬고 입/출력을 대기하고 있는 것이죠.

프로세스가 실행되면 최초에는 CPU 버스트(CPU burst)로 시작하여 CPU를 집중적으로 사용합니다. 그러다 입/출력 요청이 발생하면 입/출력 버스트(I/O burst)로 교체되고, 이후 입출력이 끝나면 다시 CPU 버스트가 실행되며 이후에는 이 두 버스트가 반복적으로 발생하는 패턴을 보입니다.

입/출력 중심의 프로그램은 전형적으로 긴 입/출력 버스트와 짧은 CPU 버스트를 가지는 편이고, CPU 지향 프로그램은 전형적으로 짧은 입/출력 버스트와 긴 CPU 버스트를 가지는 편입니다. 따라서 CPU-입/출력 버스트 분포를 파악하여 CPU 스케줄링 알고리즘을 선택해야 합니다.

### CPU 스케줄러 (CPU Scheduler)

CPU 할당을 기다리는 프로세스들이 모여있는 준비 완료 큐는 선입선출 큐, 우선순위 큐, 순서가 없는 연결 리스트 등으로 구현되어 있습니다.

입/출력 버스트 등에 의해 CPU가 유휴 상태가 될 때마다, 운영체제는 준비 완료 큐에 있는 프로세스 중 하나를 선택하여 실행해야 합니다. 이를 수행하는 것이 단기 스케줄러(Short term Scheduler 혹은, CPU 스케줄러)입니다.

준비 완료 큐에 있는 레코드들은 프로세스 제어 블록(PCB) 형태로 존재합니다.

- PCB : 해당 프로세스 상태, 다음에 실행할 명령어의 주소, 프로세스 우선순위, 프로세스와 연관된 입/출력 장치 등에 대한 다양한 프로세스 정보를 수록한 블록

### 선점 스케줄링 (Preemptive Scheduling)

특정 프로세스에 CPU가 할당되어 사용되는 도중 다음과 같은 고민되는 순간이 생깁니다. 

>- 현재 실행중인 프로세스보다 우선 순위가 높은 프로세스가 준비 완료 큐에 들어왔을 때 해당 프로세스에게 CPU를 넘겨줘야 할까?
>- 현재 프로세스가 아직 작업을 마치지 못했는데 자신에게 주어진 CPU 점유 시간을 다 채웠을 때는 어떻게 해야 할까?
>- 🤔

위와 같은 상황에서 CPU를 계속 현재 프로세스에게 할당할 것인지, 아니면 다음 프로세스에게 넘겨줄 것인지(선점)를 결정하는 것에 따라 **선점/비선점 스케줄링**을 구분합니다.

#### 선점 스케줄링 상황

CPU 선점이 발생할 수 있는 조금 더 구체적인 상황을 생각해봅시다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때(입/출력 요청이 들어왔을 때, 혹은 자식 프로세스의 종료를 기다리기 위해 wait을 호출할 때 등)
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때(인터럽트가 발생했을 때 등)
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때(입/출력 요청이 들어와 입/출력을 완료하고 입/출력이 종료될 때 등)
4. 프로세스가 종료할 때

- 위의 상황 중 1, 4의 경우에는 무조건 다음 프로세스에게 CPU를 할당해야 겠죠. 하지만 2, 3의 경우에는 현재 실행중인 프로세스가 계속 CPU를 점유할지, 혹은 준비 완료 큐의 다른 프로세스에게 CPU를 넘겨줘야할 지 결정해야 합니다.
- 만약 1, 4의 상황에서만 스케줄링이 발생할 경우, 즉 일단 CPU가 한 프로세스에 할당되면 해당 프로세스가 종료되거나 혹은 대기상태로 전환되기 전까지는 해당 프로세스가 무조건 CPU를 점유하게 되는 경우를 **비선점(non-preemptive)** 혹은 **협조적(cooperative)**이라고 합니다.(Microsoft Windows 3.1, Mac OS X 이전 Macintosh 운영체제에서 사용하던 스케줄링 기법)
- 만약 1, 4뿐만 아니라 2, 3의 상황에서도 스케줄링이 발생할 경우, 즉 준비 완료 큐에 존재하는 다른 프로세스가 현재 프로세스를 제치고 CPU를 선점하는 경우를 **선점(preemptive)**이라고 합니다.(Windows 95 이후의 Windows 운영체제, Mac OS X 이후의 Macintosh 운영체제에서 사용하는 스케줄링 기법)

선점 스케줄링의 경우 공유 자료에 대한 접근에 주의를 기울여야 합니다. 또한 비선점 스케줄링보다 운영체제 커널 설계 등이 복잡할 수 있습니다.

### 디스패쳐 (Dispatcher)

디스패쳐는 CPU 스케줄러의 결정에 의해 선택된 프로세스에게 CPU를 넘겨주는 모듈입니다. 구체적인 디스패쳐의 역할은 다음과 같습니다.

- 문맥 교환(Context Switching)
- 사용자 모드로 전환
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동

위와 같은 작업을 수행하면서 소모하는 시간을 디스패치 지연(dispatch latency)이라고 합니다.

<br>

## CPU 스케줄링 기준

CPU 스케줄링 알고리즘은 모두 서로 다른 특징을 갖고 있습니다. 특정 상황에서 더 나은 스케줄링 알고리즘을 선택하기 위해 다음과 같은 기준을 바탕으로 성능을 비교할 수 있습니다.

1. CPU 이용률 (CPU utilization)
    - CPU가 사용되는 정도

2. 처리량 (Throughput)
    - 단위 시간당 완료된 프로세스의 개수(작업량)

3. 총처리 시간 (Turnaround time)
    - 한 프로세스를 실행하는데 소요된 시간
    - 프로세스 완료 시간에서 프로세스 제출 시간을 마이너스
    - 준비 완료 큐에서 대기한 시간, CPU에서 실행하는 시간, 입/출력 시간 등을 포함

4. 대기 시간 (Waiting time)
    - 프로세스가 준비 완료 큐에서 대기하면서 보낸 시간의 합

5. 응답 시간 (Response time)
    - 대화식 시스템(interactive system)을 위한 기준
    - 응답이 시작되는 데까지 걸리는 시간

효율적인 스케줄링을 위해서는 CPU 이용률과 처리량는 최대화, 총처리 시간, 대기 시간, 응답 시간은 최소화하는 것이 바람직합니다.

<br>

## CPU 스케줄링 알고리즘

다양한 CPU 스케줄링 알고리즘을 소개합니다. 각 알고리즘의 특징과 장단점을 고려하여 프로그램에 맞는 알고리즘을 선택해야 합니다. 이 글에서 각 알고리즘의 성능은 평균 대기 시간으로 비교합니다.

### 선입 선처리 스케줄링 (First-Come, First-Served Scheduling)

- CPU를 먼저 요청한 프로세스가 CPU를 먼저 할당받습니다. 즉, 준비 완료 큐에 들어온 순서대로 프로세스를 할당받습니다.
- CPU가 자유상태가 되면 준비 완료 큐의 가장 앞에 있는 프로세스에게 CPU를 할당하고, 준비 완료 큐는 가장 앞에 위치한 프로세스를 제거합니다.
- 이 때, 준비 완료 큐는 선입선출(FIFO) 큐로 관리됩니다.
- 비선점형 스케줄링 기법입니다.
- 장점 : 구현이 쉽습니다.
- 단점
    - 최소 평균 대기 시간을 보장하지 않습니다.
    - 하나의 긴 프로세스가 CPU를 점유할 경우 모든 다른 프로세스들이 CPU 양도를 기다리는 호위효과(convoy effect)가 발생합니다. -> CPU와 장치 이용률 저하

#### 스케줄링 시뮬레이션

<p align="center"><img src="./img/fcfs_process.png" width="300"></p>
<p align="center"><img src="./img/fcfs_gantt.png" width="600"></p>

> 평균대기시간 = (0+24+27)/3 = 17

<br>

### 최단 작업 우선 스케줄링 (Shortest-Job-First Scheduling)

- 가장 작은 CPU 버스트를 가진 프로세스가 CPU를 먼저 할당받습니다.
- 단, 두 프로세스가 동일한 길이의 다음 CPU 버스트를 가질경우 선입 선처리 스케줄링을 적용합니다.
- 선점형, 비선점형 스케줄링을 모두 적용할 수 있습니다.
- 장점 : 최소 평균 대기 시간을 보장하므로 **최적** 스케줄링 기법입니다.
- 단점 : 다음 CPU 버스트 길이를 미리 파악하기 어렵습니다.(다음 CPU 버스트 길이가 이전의 버스트 길이와 유사할 것이라고 기대한 뒤 근사 값을 계산하는 방법이 있습니다.)

#### 비선점형 스케줄링 시뮬레이션

<p align="center"><img src="./img/sjf_process.png" width="300"></p>
<p align="center"><img src="./img/sjf_gantt.png" width="600"></p>

> 평균대기시간 = (3+16+9+0)/4 = 7

#### 선점형 스케줄링(최소 잔여 시간 우선 스케줄링) 시뮬레이션

<p align="center"><img src="./img/preem_sjf_process.png" width="300"></p>
<p align="center"><img src="./img/preem_sjf_gantt.png" width="600"></p>

> 평균대기시간 = ((10-1)+(1-1)+(17-2)+(5-3))/4 = 6.5

<br>

### 우선순위 스케줄링 (Priority Scheduling)

- 각 프로세스는 특정 기준에 의해 우선순위가 부여되어 있습니다. 이 기준에 의해 우선순위가 가장 높은 프로세스가 CPU를 먼저 할당받습니다.
- 단, 우선순위가 같은 프로세스들은 선입 선처리 스케줄링을 적용합니다.
- SJF 스케줄링 역시 우선순위 스케줄링의 한 종류라고 볼 수 있습니다.
- 우선순위의 기준으로는 시간 제한, 메모리 요구, 열린 파일의 수, 평균 입/출력 버스트의 평균 CPU 버스트의 비율, 프로세스의 중요도, 비용, 정치적인 요인 등이 있습니다.
- 선점형, 비선점형 스케줄링을 모두 적용할 수 있습니다.
    - 선점형 : 준비 완료 큐에 새로운 프로세스가 들어오면 현재 진행중인 프로세스와 우선순위를 비교하여 우선순위가 더 높은 프로세스가 CPU를 선점
    - 비선점형 : 현재 진행중인 프로세스를 계속 진행하되 새로 들어온 높은 우선순위의 프로세스는 준비 완료 큐의 머리 부분에 삽입
- 장점 : 우선순위를 고려할 수 있습니다.
- 단점 : 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 문제(**무한 봉쇄(indefinite blocking)** 혹은 **기아 상태(starvation)**)가 발생할 수 있습니다.
    - 위의 문제를 해결하는 방법으로 오랫동안 대기하는 프로세스들의 우선순위를 점진적으로(특정 시간마다) 증가시켜주는 기법(**노화(aging)**)을 적용할 수 있습니다.

#### 선점형 스케줄링 시뮬레이션

<p align="center"><img src="./img/priority_process.png" width="300"></p>
<p align="center"><img src="./img/priori_gantt.png" width="600"></p>

> 평균대기시간 = (6+0+16+18+1)/5 = 8.2

<br>

### 라운드 로빈 스케줄링 (Round-Robin Scheduling)

- 사전에 CPU 시간 할당량(time quantum) 또는 시간 조각(time slice)를 설정하고, 한 프로세스에게 지정된 시간 할당량만큼의 CPU 점유 시간을 부여하는 스케줄링 방법입니다. 
- 시간 할당량만큼 CPU를 점유한 프로세스에게는 인터럽트가 발생하도록 타이머를 설정한 후, 프로세스를 디스패치합니다.
- 시분할 시스템을 위해 설계된 기법입니다.
- 이 때, 준비 완료 큐는 선입선출(FIFO) 큐로 관리됩니다.
- 프로세스는 주어진 시간 할당량 이내에 작업을 완료할 수도 있고 완료하지 못할 수도 있습니다. 이 때는 다음과 같이 처리합니다.
    - 프로세스의 CPU 버스트 < 시간 할당량 : 프로세스가 종료된 이후 자신이 자발적으로 CPU를 방출
    - 프로세스의 CPU 버스트 > 시간 할당량 : 타이머가 끝나고 인터럽트가 발생되면 문맥 교환이 일어나고 실행하던 프로세스는 준비 완료 큐의 꼬리에 위치
- 선점형 스케줄링 기법입니다.
- 장점 : 프로세스가 n개 존재하고 각 프로세스 당 시간 할당량이 q라고 가정한다면, 각 프로세스는 다음 시간 할당까지 최대 (n-1) * q 이상을 대기하지 않음을 보장할 수 있습니다.
- 단점 : 시간 할당량의 크기 설정에 따라 알고리즘의 성능이 크게 영향을 받습니다.
    - 시간 할당량이 지나치게 크면 선입 선처리 스케줄링 기법과 같아질 수 있습니다.
    - 시간 할당량이 지나치게 작으면 문맥 교환 오버헤드가 커져 총처리 시간이 증가합니다.

#### 스케줄링 시뮬레이션 (시간 할당량 : 4)

<p align="center"><img src="./img/fcfs_process.png" width="300"></p>
<p align="center"><img src="./img/rr_gantt.png" width="600"></p>

> 평균대기시간 = (10+4+7)/3 = 7

<br>

### 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

- 준비 완료 큐를 다수의 별도의 큐로 분류하여 각 큐마다 제각각의 스케쥴링 알고리즘을 적용하는 방법입니다.
- 프로세스는 포어그라운드(foreground, 대화형) 프로세스와 백그라운드(background, 일괄처리) 프로세스로 구분될 수 있습니다. 일반적으로 대화형 시스템을 위해 포어그라운드 프로세스가 우선순위를 갖는 경우가 많습니다.
- 따라서 프로세스의 메모리 크기, 프로세스의 우선순위, 프로세스 유형, 프로세스 특성에 따라 각각의 프로세스는 특정 큐에 할당될 수 있습니다. 단, 프로세스는 큐 간 이동할 수는 없습니다.
- 각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가집니다. 또한 큐들 사이에 시간을 나누어 CPU를 사용하기도 합니다.
- 선점형 스케줄링 기법입니다.

### 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

- 다단계 큐 스케쥴링에서 프로세스가 큐들 사이를 이동하는 것을 허용한 방법입니다.
- 특정 프로세스가 CPU를 너무 많이 점유할 경우, 해당 프로세스를 낮은 우선순위 큐로 이동시킬 수 있습니다.
- 또한 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동(노화 기법)시킬 수 있습니다.
- 역시 각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가지고 큐들 사이에 시간을 나누어 CPU를 사용할 수도 있습니다.
- 선점형 스케줄링 기법입니다.

<br>

## 다중 처리기 스케줄링 (Multiple-Processor Scheduling)

위에서 정리한 CPU 스케줄링 기법은 단일 처리기 시스템 하에서 하나의 CPU를 어떻게 스케줄링할 것인지 결정했습니다. 하지만 CPU가 여러개라면 여러개의 CPU를 여러 프로세스에게 할당해야하는 더 복잡한 문제가 발생합니다. 다중 처리기 시스템에서는 CPU 스케줄링을 어떻게 결정할까요? 또한 무엇을 고려해야 할까요?

### 다중 처리기 시스템에서의 스케줄링 결정 대상

1. 비대칭 다중 처리(asymmetric multiprocessing)

    - 주 서버라는 하나의 처리기가 모든 스케줄링 결정을 내립니다.
    - 다른 서브 처리기들은 주 서버의 결정에 따라 사용자의 코드만을 수행합니다.
    - 주 서버 처리기만 시스템 자료 구조에 접근하므로 자료 공유로인한 문제가 발생하지 않습니다.

2. 대칭적 다중 처리(symmetric multiprocessing, SMP)

    - 각 처리기가 독자적으로 스케줄링을 합니다.
    - 각 처리기는 공통의 준비 완료 큐에서 프로세스를 선택할 수도 있고, 자신만의 독자적인 준비 완료 큐를 구성할 수도 있습니다.
    - 다중 처리기가 공동의 시스템 자료 구조에 접근하므로 자료 공유 문제를 고려해야 합니다.
    - 또한 공통의 준비 완료 큐를 사용할 경우 다중 처리기가 공통된 프로세스를 선택하지 않도록 조심해야 합니다.

### 다중 처리기 시스템에서의 스케줄링 쟁점

- 처리기 친화성 (Processor Affinity)

프로세스가 여러 처리기로 이동하게 될 경우 캐시 메모리를 채우고 비우는 오버헤드가 발생합니다.

따라서 한 처리기에서 다른 처리기로의 이주를 피하고, 대신 같은 처리기에서 프로세스를 실행시키려고 하는 현상을 보이는데 이 현상을 처리기 친화성이라고 합니다.

- 부하 균등화 (Load Balancing)

모든 처리기 사이의 부하가 고르게 배분되도록 하는 것을 말합니다. 대칭적 다중 처리 시스템에서 여러 처리기를 최적으로 활용하기 위해서는 부하 균등화가 잘 이루어져야 합니다.

부하 균등화는 대칭적 다중 처리 시스템의 각 처리기가 공통의 준비 완료 큐가 아닌 자기 자신만의 큐를 가지고 있을 때 적용 가능합니다. 한 처리기가 과부하 상태일 때 여유로운 처리기로 프로세스를 이동시키는 것을 push, 여유로운 처리기에서 과부하 처리기의 프로세스를 이주시키는 것을 pull 이라 합니다.

단, 부하 균등화는 위에서 소개한 처리기 친화성과 상충되므로 사전에 부하 불균형 상태에 대한 적절한 정의가 이루어져야 합니다.

- 대칭적 다중 쓰레딩 (Symmetric Multithreading)

대칭적 다중 처리 시스템은 다수의 물리적인 처리기를 제공하는 것을 말합니다. 이와 달리 동일한 물리 처리기 상에 다수의 논리적인 처리기를 제공하여 다수의 쓰레드가 동시에 실행되도록 하는 것을 **대칭적 다중 쓰레딩(SMT, 하이퍼쓰레딩 기술(hyperthreading technology))**라고 합니다.

논리적인 처리기는 하나의 물리적인 처리기 내부에 여러개 존재할 수 있습니다. 이 논리적인 처리기들은 캐시 메모리, 버스 등과 같은 자신이 속한 물리적인 처리기의 자원을 공유하며 사용합니다.

<br>


# Deadlock 교착상태

## 교착상태란?

한 프로세스 집합 내의 모든 프로세스가 그 집합 내의 다른 프로세스에 의해서만 발생될 수 있는 사건을 기다리는 상황이 발생하여, 프로세스들이 모두 무한정 대기에 빠지는 것을 말합니다.

> 예를 들어봅시다. 프로세스는 자원을 사용하기 위해 **요청**, **사용**, **방출** 순서를 지켜야합니다.  
> 3개의 CD RW 드라이브를 가진 시스템에서 3개의 프로세스가 각각의 CD RW 드라이브를 사용하고 있는 상태라고 가정합니다. 만약 이 상황에서 3개의 프로세스가 또 다른 드라이브를 요청할 경우, 세 프로세스는 교착상태에 빠지게 됩니다. 모든 프로세스는 다른 대기중인 프로세스에 의해 드라이브가 방출되어야지만 대기에서 빠져나올 수 있기때문입니다.

<br>

## 교착상태의 특징

### 교착상태 발생의 필요 조건

교착상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있습니다.

1. 상호 배제(Mutual exclusion)
    - 최소한 하나의 자원이 비공유 모드(하나의 자원은 한 번에 한 프로세스만 사용할 수 있음)로 점유되어야 합니다.
    - 다른 프로세스가 그 자원을 요청할 경우, 요청 프로세스는 자원이 방출될 때까지 대기해야 합니다.
2. 점유하며 대기(Hold-and-wait)
    - 프로세스는 최소한 하나의 자원을 점유한 상태로, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기해야 반드시 합니다.
3. 비선점(No preemption)
    - 자원이 강제적으로 방출될 수 없습니다.
    - 점유하고 있는 프로세스가 태스크를 종료한 후 그 프로세스에 의해 자발적으로만 방출될 수 있습니다.
4. 순환 대기(Circular wait)
    - 대기하고 있는 프로세스 집합 {p0, p1, ..., pn}에서 p0은 p1이 점유한 자원을 대기하고, p1은 p2가 점유한 자원을 대기하고, pn은 p0이 점유한 자원을 대기하는 것과 같은 상황입니다.
    - 즉, 대기하는 방향이 순환하는 형태입니다.

### 자원 할당 그래프(Resource-Allocation Graph)

교착상태는 정점(vertex, V)과 간선(edge, E) 집합으로 표현할 수 있습니다.

- 정점
    - 시스템 내의 모든 활성 프로세스(원으로 표현)
    - 시스템 내의 모든 자원 유형(사각형으로 표현)
- 간선
    - 프로세스의 자원 요청 관계(프로세스에서 자원으로의 화살표로 표현)
    - 자원의 프로세스 할당 관계(자원에서 프로세스로의 화살표로 표현)

![resource-allocation-graph](./img/resource-allocation-graph1.png)

![resource-allocation-graph](./img/resource-allocation-graph2.png)

<br>

## 교착상태 처리 방법

원칙적으로 교착상태 문제를 처리하는 데에는 다음과 같은 세 가지 방법이 존재합니다.

- 시스템이 교착상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 이용합니다.
- 시스템이 교착상태가 되도록 허용한 다음 회복시킵니다.
- 문제를 무시하고, 교착상태가 시스템에서 발생하지 않은 척 합니다.

놀랍게도 UNIX와 Windows를 비롯한 대부분의 운영체제는 세 번째 방법을 사용합니다. 이는 드물게 발생하는 교착상태에 대해 처리 비용과 오버헤드가 큰 교착상태 예방, 회피 및 탐지, 복구 알고리즘을 적용하는 것보다 수작업으로 시스템을 중지하고 재시작하는 것이 더 낫다고 판단하기 때문입니다.

<br>

### 교착상태 예방(Deadlock Prevention)

교착상태를 예방하기 위해서는 앞서 언급한 4가지의 교착 상태 발생 필요 조건 중 적어도 하나가 성립하지 않도록 보장해야 합니다.

#### 1. 상호 배제

상호 배제 조건은 공유가 불가능한 자원에 대해서는 반드시 성립해야 합니다. 따라서 근본적으로 동시 접근을 허용할 수 없는 자원이라면 상호배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능합니다.

#### 2. 점유하며 대기

점유하며 대기 조건의 성립을 막기 위해, 프로세스가 자원을 요청할 때는 다른 자원들을 점유하지 않을 것을 보장해야 합니다. 이를 위한 방법으로는 2가지가 존재합니다.

- 프로세스가 실행되기 전 자신이 필요로하는 모든 자원을 최초에 한 번에 요청하고 할당받습니다.
- 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용합니다.

> 예를 들어봅시다. DVD 드라이브로부터 자료를 받아 디스크 파일로 저장하고 이를 프린터로 출력하는 프로세스가 존재합니다. 전자의 방법을 적용할 경우 프로세스는 초기에 DVD 드라이브, 디스크 파일, 프린터를 요청해야 합니다. 후자의 방법을 적용할 경우 프로세스는 DVD 드라이브, 디스크 파일을 먼저 요청하여 사용한 뒤 이를 방출하고 나서 프린터를 요청하고 사용할 수 있습니다.

두 방법에는 모두 단점이 존재합니다. 전자의 경우 많은 자원들이 한꺼번에 할당된 후 오랜 기간 동안 사용되지 않고 점유될 수 있기때문에 **자원의 이용도가 낮을 수 있습니다**. 후자의 경우 자신이 필요한 자원 중 최소 하나 이상이 항상 다른 프로세스에게 할당되어 있기 때문에 **기아 상태**에 빠질 수 있습니다.

#### 3. 비선점

비선점 조건의 성립을 막기 위해서는, 어떤 자원을 점유하고 있는 프로세스가 다른 자원을 요청했지만 해당 자원을 당장 프로세스에게 할당할 수 없는 경우(즉, 대기가 발생할 경우) 프로세스가 원래 점유하고 있던 자원이 선점될 수 있도록 합니다.

#### 4. 순환 대기

순환 대기 조건의 성립을 막기 위해서는, 모든 자원 유형들에게 순서를 부여하여 프로세스가 열거된 순서대로 자원을 요청하도록 요구해야 합니다.

<br>

### 교착상태 회피(Deadlock Avoidance)

위의 방법들로 교착상태를 예방할 수 있지만, 장치 이용률이 저하되고 시스템 처리율이 감소된다는 한계가 존재합니다.

다른 접근으로는 **프로세스가 일생 동안 요청하고 사용할 자원에 대한 정보를 사전에 제공받아, 교착상태를 미리 예측**하는 방법이 있습니다. 이를 위해서는 현재 가용 자원, 현재 각 프로세스에게 할당된 자원, 각 프로세스가 앞으로 요청하거나 방출할 자원을 고려해야 합니다.

2가지의 교착상태 회피 알고리즘이 존재합니다. 이 알고리즘을 통해 시스템 **안전 상태**(프로세스들이 요청하는 모든 자원을 교착 상태를 발생시키지 않고 할당해줌)를 판단할 수 있습니다. 시스템이 불안전 상태라고 할지라도 교착상태에 빠지지 않을 수 있지만, 교착상태에 빠진다면 불안전 상태에 존재하게 됩니다. 따라서 시스템을 안전 상태로 유지한다면 교착상태를 예방할 수 있습니다.

#### 자원 할당 그래프 알고리즘

시스템의 각 자원 유형 별로 *단 하나의 인스턴스*만 존재하는 경우 자원 할당 그래프를 조금 변형시켜 교착 상태를 예견할 수 있습니다.

요청 간선과 할당 간선에 **예약 간선**이라는 새로운 유형을 도입합니다. 예약 간선은 프로세스가 미래에 해당 자원을 요청할 것이라는 의미를 내포합니다. 따라서 프로세스 실행 전 모든 예약 간선을 자원 할당 그래프에 명시해둔다면 교착 상태가 발생할 것을 사전에 예측할 수 있습니다.

![resource-allocation-graph-algorithm](./img/resource-allocation-graph-algorithm.png)

예약 간선을 할당 간선으로 변환시켜도 자원 할당 그래프에 사이클이 형성되지 않을 때에만 자원을 할당한다면 교착 상태가 발생하는 것을 피할 수 있습니다.

#### 은행원 알고리즘(Banker's Algorithm)

시스템의 각 자원 유형 별로 *여러개의 인스턴스*가 존재하는 경우 적용할 수 있는 알고리즘입니다.

이름에서 볼 수 있듯이 은행에서 돈을 빌리려는 다수의 고객이 존재할 때, 은행이 파산하지 않고 모든 고객에게 돈을 빌려주는 원리를 이용합니다.

> 예를 들어 봅시다. 100달러를 보유하고 있는 은행에 3명의 고객이 찾아와 각각 60달러, 40달러, 50달러씩 대출하기를 신청했습니다.
> 은행은 먼저 고객1에게는 20달러를, 고객2와 고객3에게는 30달러씩 빌려줍니다. 은행은 수중에 20달러가 남습니다.
> 이후 고객2에게 남은 10달러를 빌려주고 기다립니다. 고객2가 40달러를 상환하면 은행은 수중에 50달러가 남습니다.
> 이후 고객1에게 남은 40달러를 빌려주고 기다립니다. 고객1이 60달러를 상환하면 은행은 수중에 70달러가 남습니다.
> 이후 고객3에게 남은 20달러를 빌려주고 기다립니다. 고객3이 50달러를 상환하면 은행은 파산하지 않고 모든 고객게에 돈을 빌려줄 수 있습니다.
> 하지만 3번째 단계에서 은행이 고객1에게 남은 20달러를 모두 빌려줬다면 고객 중 상환할 수 있는 사람은 없고, 모두 대출을 받기 위해 기다려야 하는 상태에 빠지게 되어 파산하게 됩니다. -> 교착상태

이 방법과 같이 시스템은 **프로세스의 자원 요청을 허가**했을 때 시스템이 **안전 상태에 머무른다면 요청을 들어주고** 그렇지 않다면 프로세스를 대기시킵니다. 안전 상태에서 머무를 수 있도록 하는 안전 순서열이 존재한다면 시스템의 교착상태를 막을 수 있습니다.

이를 구현하기 위해 다음과 같은 자료구조가 필요합니다

- 가용(Available) : 각 종류의 자원이 현재 몇 개가 가용한지 나타내는 벡터
    - `Available[j] = k` : 현재 Rj를 k개 사용할 수 있음
- 최대(Max) : 각 프로세스가 최대로 필요로하는 자원의 개수를 나타내는 행렬
    - `Max[i, j] = k` : Pi가 Rj를 최대 k개 요청할 수 있음
- 할당(Allocation) : 각 프로세스에게 현재 할당되어 있는 자원의 개수를 나타내는 행렬
    - `Allocation[i,j] = k` : 현재 Pi가 Rj를 k개 사용하고 있음
- 요구(Need) : 각 프로세스가 향후 요구할 수 있는 자원의 개수를 나타내는 행렬
    - `Need[i,j] = k` : 향후 Pi가 Rj를 k개까지 요청할 수 있음
    - `Max[i, j] - Allocation[i,j] = Need[i,j]`

##### 안정성 알고리즘(Safty Algorithm)

시스템이 안전한지 판단하는 알고리즘 입니다. n은 프로세스 수를, m은 자원 종류의 수를 나타냅니다.

1. Work(향후 사용 가능한 자원 수)와 Finish(자원을 모두 사용하여 작업이 끝난 프로세스 수)는 각각 크기가 m과 n인 벡터이다. Work = Available로 초기화한다. 프로세스의 번호를 나타내는 i를 대상으로 Finish[i] = false로 초기화한다.
2. 두 조건을 만족시키는 i를 찾는다. 만약 그러한 i를 찾지 못하면 step 4로 간다.
    - Finish[i] == false
    - Needi <= Work
3. 아래 두 연산을 수행하고 step 2로 간다.
    - Work = Work + Allocationi
    - Finish[i] = true
4. 모든 i에 대해 Finish[i] == true이면 이 시스템은 안전 상태에 있다.

![banker's-algorithm](./img/banker's-algorithm.png)

<br>

### 교착 상태 탐지(Deadlock Detection)

시스템이 교착상태 예방이나 교착상태 방지 알고리즘을 사용하지 않는다면 결국에는 교착상태가 발생하게 됩니다. 이러한 환경에서는 교착상태가 발생했는지 확인하기 위한 시스템 상태 검사 알고리즘과 교착 상태로부터 회복하는 알고리즘이 필요합니다.

교착상태 탐지는 자원 유형 별 개수에 따라 다른 방법을 적용합니다.

1. 자원 유형이 한 개씩 있는 경우

자원 할당 그래프를 변형시킨 대기 그래프를 활용하여 교착상태를 탐지할 수 있습니다. 대기 그래프가 사이클을 포함할 경우 시스템에 교착상태가 존재한다고 판단할 수 있습니다.

![wait-for-graph](./img/wait-for-graph.png)

2. 자원 유형 별 자원이 여러개 있는 경우

교착상태 회피 알고리즘의 은행원 알고리즘과 유사합니다. 가용(Available), 할당(Allocation), 요청(Request) 자료구조를 이용하여 모든 프로세스가 요구하는 자원을 충족시켜줄 안전 순서열이 존재하는지 여부를 파악합니다.

**교착상태 발생 빈도**와 **교착상태 발생 시 몇 개의 프로세스가 연루되는지**에 따라 교착상태 탐지 알고리즘을 실행시킬 수 있습니다. 프로세스의 요청이 즉시 만족되지 않을 때마다 탐지 알고리즘을 실행시킨다면, 교착상태를 야기한 프로세스를 파악할 수 있지만 오버헤드가 크게 발생할 수 있다는 딜레마가 존재합니다.

<br>

### 교착 상태로부터 회복

교착상태에서 빠져나오기 위해 시스템은 두 가지 방법을 시도할 수 있습니다. 첫 번째 방법은 프로세스를 중지시킴으로써 순환 대기를 깨뜨리는 것이고, 두 번째 방법은 프로세스로부터 자원을 선점하는 것입니다.

한가지 중요한 것은 탐지와 회복 과정에서 이러한 알고리즘을 실행시키기 위한 비용 뿐만 아니라, 교착상태가 발생했을 때 부가적으로 나타나는 손실을 고려해야 한다는 것입니다.

#### 프로세스 종료(Process Termination)

- 교착상태의 프로세스들을 모두 중지
    - 프로세스가 그동안 연산한 내용이 모두 폐기되므로 비용이 큼
- 교착상태에서 빠져나올 때까지 한 프로세스씩 중지
    - 각 프로세스가 중지될 때마다 교착 상태 탐지 알고리즘을 호출해야 하므로 오버헤드가 유발됨

프로세스를 중간에 중지시키는 것은 결코 쉬운 방법은 아닙니다. 프로세스가 작업하던 파일을 손상시킬 수도 있고, 또 어떤 프로세스를 중지시킬 지 결정하는 데에도 비용이 들어갑니다.

#### 자원 선점(Resource Preemption)

교착상태를 해결하기 위해 선점을 할경우 **희생자를 선택**해야 하고, **롤백 상태를 선택**해야 하며, **기아 상태**가 발생하지 않도록 해야합니다.

<br>

## 결론

다양한 교착상태 방지 기법이 존재하지만 어떤 방법도 단독으로 사용하기에는 한계가 존재합니다. 따라서 최적의 해결책을 선택하기 위해서는 위의 기본 방법들을 적절하게 조합하여 사용해야 합니다.
